<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to write a constraint · SpineOpt.jl</title><meta name="title" content="How to write a constraint · SpineOpt.jl"/><meta property="og:title" content="How to write a constraint · SpineOpt.jl"/><meta property="twitter:title" content="How to write a constraint · SpineOpt.jl"/><meta name="description" content="Documentation for SpineOpt.jl."/><meta property="og:description" content="Documentation for SpineOpt.jl."/><meta property="twitter:description" content="Documentation for SpineOpt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SpineOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpineOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/setup_workflow/">Setting up a workflow</a></li><li><a class="tocitem" href="../../getting_started/creating_your_own_model/">Creating Your Own Model</a></li><li><a class="tocitem" href="../../getting_started/archetypes/">Archetypes</a></li><li><a class="tocitem" href="../../getting_started/output_data/">Managing Outputs</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorial/webinars/">Webinars</a></li><li><a class="tocitem" href="../../tutorial/simple_system/">Simple system</a></li><li><a class="tocitem" href="../../tutorial/reserves/">Reserve requirements</a></li><li><a class="tocitem" href="../../tutorial/ramping/">Ramping constraints</a></li><li><a class="tocitem" href="../../tutorial/unit_commitment/">Unit Commitment</a></li><li><a class="tocitem" href="../../tutorial/tutorialTwoHydro/">Two hydro plants</a></li><li><a class="tocitem" href="../../tutorial/case_study_a5/">Case Study A5</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../how_to/change_the_solver/">Change the solver</a></li><li><a class="tocitem" href="../../how_to/define_an_efficiency/">Define an efficiency</a></li><li><a class="tocitem" href="../../how_to/print_the_model/">Print the model</a></li></ul></li><li><span class="tocitem">Concept Reference</span><ul><li><a class="tocitem" href="../../concept_reference/the_basics/">Basics of the model structure</a></li><li><a class="tocitem" href="../../concept_reference/Object Classes/">Object Classes</a></li><li><a class="tocitem" href="../../concept_reference/Relationship Classes/">Relationship Classes</a></li><li><a class="tocitem" href="../../concept_reference/Parameters/">Parameters</a></li><li><a class="tocitem" href="../../concept_reference/Parameter Value Lists/">Parameter Value Lists</a></li></ul></li><li><span class="tocitem">Mathematical Formulation</span><ul><li><a class="tocitem" href="../../mathematical_formulation/variables/">Variables</a></li><li><a class="tocitem" href="../../mathematical_formulation/constraints_automatically_generated/">Constraints</a></li><li><a class="tocitem" href="../../mathematical_formulation/objective_function/">Objective</a></li></ul></li><li><span class="tocitem">Advanced Concepts</span><ul><li><a class="tocitem" href="../../advanced_concepts/temporal_framework/">Temporal Framework</a></li><li><a class="tocitem" href="../../advanced_concepts/stochastic_framework/">Stochastic Framework</a></li><li><a class="tocitem" href="../../advanced_concepts/unit_commitment/">Unit Commitment</a></li><li><a class="tocitem" href="../../advanced_concepts/ramping/">Ramping</a></li><li><a class="tocitem" href="../../advanced_concepts/reserves/">Reserves</a></li><li><a class="tocitem" href="../../advanced_concepts/investment_optimization/">Investment Optimization</a></li><li><a class="tocitem" href="../../advanced_concepts/user_constraints/">User Constraints</a></li><li><a class="tocitem" href="../../advanced_concepts/decomposition/">Decomposition</a></li><li><a class="tocitem" href="../../advanced_concepts/powerflow/">PTDF-Based Powerflow</a></li><li><a class="tocitem" href="../../advanced_concepts/pressure_driven_gas_transfer/">Pressure driven gas transfer</a></li><li><a class="tocitem" href="../../advanced_concepts/Lossless_DC_power_flow/">Lossless nodal DC power flows</a></li><li><a class="tocitem" href="../../advanced_concepts/representative_days_w_seasonal_storage/">Representative days with seasonal storages</a></li><li><a class="tocitem" href="../../advanced_concepts/cumulated_flow_restrictions/">Imposing renewable energy targets</a></li><li><a class="tocitem" href="../../advanced_concepts/mga/">Modelling to generate alternatives</a></li></ul></li><li><span class="tocitem">Implementation details</span><ul><li><a class="tocitem" href="../documentation/">Documentation</a></li><li><a class="tocitem" href="../how_does_the_model_update_itself/">How does the model update itself</a></li><li class="is-active"><a class="tocitem" href>How to write a constraint</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#First-steps"><span>First steps</span></a></li><li><a class="tocitem" href="#Into-the-code"><span>Into the code</span></a></li></ul></li><li><a class="tocitem" href="../time_slices/">Time slices</a></li></ul></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implementation details</a></li><li class="is-active"><a href>How to write a constraint</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How to write a constraint</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/spine-tools/SpineOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/spine-tools/SpineOpt.jl/blob/master/docs/src/implementation_details/how_to_write_a_constraint.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
</script><h1 id="Write-a-constraint-for-SpineOpt"><a class="docs-heading-anchor" href="#Write-a-constraint-for-SpineOpt">Write a constraint for SpineOpt</a><a id="Write-a-constraint-for-SpineOpt-1"></a><a class="docs-heading-anchor-permalink" href="#Write-a-constraint-for-SpineOpt" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Writing a constraint in SpineOpt is a bit of an art. This is possibly due to the enormous flexibility that is allowed for the temporal and stochastic structures, which might lead to situations some consider to be... unnatural.</p><p>This guide will demonstrate an almost systematic way to do it, but it&#39;s not a silver-bullet kind of recipe. Most probably you will need to adapt it to your particular needs the day you dare writing your first constraint.</p><p>What has proven useful to me is to combine a little bit of a theoretical approach with a more of a practical approach. In other words, I begin by following certain predetermined steps, see what comes out of it for a meaningful example system, and then refine. Hopefully the process converges at some point, and because I have been looking at the output for an example system, I almost already have the unit-test that will consolidate the whole process and make me look like a good programmer.</p><p>Let&#39;s begin! We will be trying to write a simplified version of the unit capacity constraint, looking as follows:</p><p class="math-container">\[\begin{aligned}
&amp; v^{unit\_flow}_{(u,n,d,s,t)} \leq p^{unit\_capacity}_{(u,n,d,s,t)} \cdot \left( v^{units\_on}_{(u,s,t)} - \left(1 - p^{shut\_down\_limit}_{u,n,d,s,t} \right) \cdot v^{units\_shut\_down}_{(u,s,t+1)} \right) \\
&amp; \forall (u, n, d) \in unit\_\_from\_node \cup unit\_\_to\_node: p^{unit\_capacity}_{(u,n,d)} \neq null \\
&amp; \forall (s, t)
\end{aligned}\]</p><p>In other words, the <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> between a <a href="../../concept_reference/Object Classes/#unit">unit</a> and a <a href="../../concept_reference/Object Classes/#node">node</a> has to be lower than or equal to:</p><ul><li>the specified <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>, if the <a href="../../concept_reference/Object Classes/#unit">unit</a> is online and not shutting down in the next period;</li><li>the <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> multiplied by the <a href="../../concept_reference/Parameters/#shut_down_limit">shut_down_limit</a>, if the <a href="../../concept_reference/Object Classes/#unit">unit</a> is shutting down in the next period;</li><li>zero, if the <a href="../../concept_reference/Object Classes/#unit">unit</a> is offline.</li></ul><p>Note that we ignore the <a href="../../concept_reference/Parameters/#start_up_limit">start_up_limit</a> in this formulation, just for simplicity. (And actually, it looks like we also assume that a unit cannot start up and shut down in the same period.)</p><h2 id="First-steps"><a class="docs-heading-anchor" href="#First-steps">First steps</a><a id="First-steps-1"></a><a class="docs-heading-anchor-permalink" href="#First-steps" title="Permalink"></a></h2><p>So how do we proceed? Well, we said above that there were some kind of steps that one could follow. They actually look like this:</p><ol><li><p>Collect the constraint indices.</p><p>a. Collect the &#39;spatial&#39; indices.</p><p>b. Collect the &#39;temporal&#39; indices.</p><p>c. Collect the &#39;stochastic&#39; indices.</p></li><li><p>Write the constraint expression.</p></li></ol><p>That&#39;s it!? Well, it actually is a bit more complex than that. Let&#39;s expand...</p><h3 id="Collect-the-constraint-indices"><a class="docs-heading-anchor" href="#Collect-the-constraint-indices">Collect the constraint indices</a><a id="Collect-the-constraint-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Collect-the-constraint-indices" title="Permalink"></a></h3><h4 id="Collect-the-&#39;spatial&#39;-indices"><a class="docs-heading-anchor" href="#Collect-the-&#39;spatial&#39;-indices">Collect the &#39;spatial&#39; indices</a><a id="Collect-the-&#39;spatial&#39;-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Collect-the-&#39;spatial&#39;-indices" title="Permalink"></a></h4><p>This is probably the simplest part, as you just need to identify the system elements that would be affected by the constraint. In our case, it will probably be the tuples of <a href="../../concept_reference/Object Classes/#unit">unit</a> and <a href="../../concept_reference/Object Classes/#node">node</a> associated via <a href="../../concept_reference/Relationship Classes/#unit__from_node">unit__from_node</a> and/or <a href="../../concept_reference/Relationship Classes/#unit__to_node">unit__to_node</a> for which <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> is specified.</p><h4 id="Collect-the-&#39;temporal&#39;-indices"><a class="docs-heading-anchor" href="#Collect-the-&#39;temporal&#39;-indices">Collect the &#39;temporal&#39; indices</a><a id="Collect-the-&#39;temporal&#39;-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Collect-the-&#39;temporal&#39;-indices" title="Permalink"></a></h4><p>This is a bit harder. Here you need to answer two questions:</p><ol><li>how often the constraint needs to be enforced;</li><li>for each of those moments, how far in time do we need to look in order to enforce the constraint.</li></ol><p>To answer the first question, the first step is to understand where the different variables involved in your constraint get their temporal resolution from. In our case, we have <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a>, <a href="../../mathematical_formulation/variables/#units_on">units_on</a> and <a href="../../mathematical_formulation/variables/#units_shut_down">units_shut_down</a>. The former gets its resolution from the associated <a href="../../concept_reference/Object Classes/#node">node</a>, via <a href="../../concept_reference/Relationship Classes/#node__temporal_block">node__temporal_block</a>; whereas the two latter get it from the <a href="../../concept_reference/Object Classes/#unit">unit</a>, via <a href="../../concept_reference/Relationship Classes/#units_on__temporal_block">units_on__temporal_block</a>.</p><p>If all <a href="../../concept_reference/Object Classes/#node">node</a>s and <a href="../../concept_reference/Object Classes/#unit">unit</a>s had the same temporal resolution, there would be no questions to be asked. We&#39;d just take that unique resolution and enforce the constraint at that rate. But since each <a href="../../concept_reference/Object Classes/#unit">unit</a> and <a href="../../concept_reference/Object Classes/#node">node</a> is allowed to have their own temporal resolutions (that&#39;s right, <em>resolutions</em> in plural), there are several questions to be asked: What happens if, e.g., the <a href="../../concept_reference/Object Classes/#unit">unit</a> has higher resolution than the <a href="../../concept_reference/Object Classes/#node">node</a> (or vice versa)? What happens if the <a href="../../concept_reference/Object Classes/#unit">unit</a> and/or the <a href="../../concept_reference/Object Classes/#node">node</a> have multiple resolutions running in parallel? What happens if their resolutions change over time?</p><p>Ultimately, the question we need to ask ourselves is what is the &#39;lowest-resolution way&#39; in which we can combine the individual resolutions of all our &#39;spatial&#39; indices so we never miss a period where we should be enforcing the constraint. In our case, we need to guarantee that the flow between a <a href="../../concept_reference/Object Classes/#unit">unit</a> and a <a href="../../concept_reference/Object Classes/#node">node</a> is <em>never</em> higher than the <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>. So it looks like we should be taking the <em>highest</em> resolution of the <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> variable.</p><p>But we also need to guarantee that the flow is lower than the <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> times the <a href="../../concept_reference/Parameters/#shut_down_limit">shut_down_limit</a> if the <a href="../../concept_reference/Object Classes/#unit">unit</a> is shutting down in the next period. How does that affect the resolution of the constraint? Is it still Ok to use the resolution of <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a>? What happens if <a href="../../mathematical_formulation/variables/#units_on">units_on</a> has higher resolution than <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a>? Would we violate this last part of the constraint eventually?</p><p>In doubt, something that could work is to take the highest resolution of all the individual resolutions involved. That should ensure that we don&#39;t miss any time-slice, but at the same time it might not be the most efficient...</p><p>Now, to answer the second question, how far in time do we need to look, we typically just need to check out our constraint expression. In our case, we need to look at the current time-slice, but also at the <em>next</em> time-slice to check if the unit is shutting down in that time-slice.</p><p>So in our case, the &#39;temporal&#39; indices will be tuples of (current time-slice, next time-slice).</p><h4 id="Collect-the-&#39;stochastic&#39;-indices"><a class="docs-heading-anchor" href="#Collect-the-&#39;stochastic&#39;-indices">Collect the &#39;stochastic&#39; indices</a><a id="Collect-the-&#39;stochastic&#39;-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Collect-the-&#39;stochastic&#39;-indices" title="Permalink"></a></h4><p>Primer on SpineOpt&#39;s stochastic framework (more details in the <a href="../../advanced_concepts/stochastic_framework/#Stochastic-Framework">Stochastic Framework</a> section). In SpineOpt, each <a href="../../concept_reference/Object Classes/#unit">unit</a> and <a href="../../concept_reference/Object Classes/#node">node</a> has one (and only one) <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a> associated via <a href="../../concept_reference/Relationship Classes/#units_on__stochastic_structure">units_on__stochastic_structure</a> and <a href="../../concept_reference/Relationship Classes/#node__stochastic_structure">node__stochastic_structure</a>, respectively - which represents their &#39;stochastic dimension&#39;.</p><p>But what <em>is</em> a <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a>? To answer this question, let&#39;s consider a directed acyclic graph (DAG) where the vertices are all the <a href="../../concept_reference/Object Classes/#stochastic_scenario">stochastic_scenario</a>s in the model,  and the edges are given by the <a href="../../concept_reference/Relationship Classes/#parent_stochastic_scenario__child_stochastic_scenario">parent_stochastic_scenario__child_stochastic_scenario</a> relationships. A <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a> is basically defining a <em>subset</em> of this DAG, including only those <a href="../../concept_reference/Object Classes/#stochastic_scenario">stochastic_scenario</a>s associated to it via <a href="../../concept_reference/Relationship Classes/#stochastic_structure__stochastic_scenario">stochastic_structure__stochastic_scenario</a>, and where the point in time where each <a href="../../concept_reference/Object Classes/#stochastic_scenario">stochastic_scenario</a> gives way to their children is determined by the <a href="../../concept_reference/Parameters/#stochastic_scenario_end">stochastic_scenario_end</a> parameter. For example:</p><div class="mermaid">
    flowchart LR;
    scen1--06:00-->scen2a;
    scen1--06:00-->scen2b;
    scen1--06:00-->scen2c;
    scen2a--15:00-->scen3;
    scen2b--15:00-->scen3;
    scen2c--12:00-->scen3;
</div><p>Above we have <code>scen1</code> branching into <code>scen2a</code>, <code>scen2b</code>, and <code>scen2c</code>; and then all these converging into <code>scen3</code>. Note that <code>scen2c</code> ends a bit earlier than <code>scen2a</code> and <code>scen2b</code> - just to make it more interesting.</p><p>So essentially, in a structure like the above, a given range of time may &#39;coexist&#39; in many scenario branches - or &#39;paths&#39;, as we like to call them in SpineOpt. For example, the interval <code>[15:00, 18:00]</code> exists in paths <code>scen2a -&gt; scen3</code> and <code>scen2b -&gt; scen3</code> - but not in <code>scen2c -&gt; scen3</code>.</p><p>Now, in the context of a SpineOpt constraint, we will have a <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a> like the above, given by the &#39;spatial&#39; indices, and a range of time determined by the &#39;temporal&#39; ones. So we will find our range of time replicated in multiple paths. That means the constraint needs to be enforced in each of those paths, or, in other words, each of those paths has to be a different &#39;stochastic&#39; index for our constraint.</p><h3 id="Write-the-constraint-expression"><a class="docs-heading-anchor" href="#Write-the-constraint-expression">Write the constraint expression</a><a id="Write-the-constraint-expression-1"></a><a class="docs-heading-anchor-permalink" href="#Write-the-constraint-expression" title="Permalink"></a></h3><p>Here you just write the constraint expression using JuMP - so if you&#39;re moderately familiar with JuMP, that&#39;s a good start.</p><p>But there is one big caveat. You will of course need to include SpineOpt variables in your expression, and each variable has their own indexing. There is no guarantee that the constraint indices you&#39;ve selected in the previous step will match those of all the variables in your constraint - so for each variable you want to include, you will need to somehow translate your constraint indices into that variable.</p><p>The good news is for each variable in SpineOpt, we have a corresponding function that returns all the indices of that variable. The even better news is the same function also allows you to do some filtering on each dimension, so you can easily obtain all the indices matching a condition. For example, you can tell to this function, &#39;give me all the <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> indices where the <a href="../../concept_reference/Object Classes/#unit">unit</a> is <code>u</code>, the <a href="../../concept_reference/Object Classes/#node">node</a> is a member of the node group <code>ng</code>, the time-slice is one of those <em>contained</em> in <code>t</code>, and the <a href="../../concept_reference/Object Classes/#stochastic_scenario">stochastic_scenario</a> is one of the stochastic path <code>s_path</code>&#39;.</p><p>So basically you can use that function to obtain all the indices of the variable that match the indices of your constraint. Yes, it can be more than one! That&#39;s why most of the terms in SpineOpt constraints are summations. For example, the summation, over all the <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> variable&#39;s indices, <code>i</code>, matching the constraint index; of the product between a certain parameter and the <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> variable for that <code>i</code>.</p><p>Hopefully all the above will become clearer with an example - so let&#39;s dive into it!</p><h2 id="Into-the-code"><a class="docs-heading-anchor" href="#Into-the-code">Into the code</a><a id="Into-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Into-the-code" title="Permalink"></a></h2><h3 id="The-test-system"><a class="docs-heading-anchor" href="#The-test-system">The test system</a><a id="The-test-system-1"></a><a class="docs-heading-anchor-permalink" href="#The-test-system" title="Permalink"></a></h3><p>I said above that I liked to combine a theoretical approach with a more of a practical approach. I guess what I meant is I don&#39;t want to do too much thinking - I want to constantly validate my code against a meaningful example.</p><p>So let&#39;s try and define a test system that triggers the creation of our constraint, is complex enough so we don&#39;t miss any relevant cases, but not that complex that we&#39;re unable to diagnose it. Maybe something like the below:</p><pre><code class="language-julia hljs">using Dates
using SpineInterface
using SpineOpt

url_in = &quot;sqlite:///my_unit_flow_capacity_constraint.sqlite&quot;

import_data(url_in, SpineOpt.template(), &quot;Add template&quot;)
import_data(
    url_in,
    &quot;Add test data&quot;;
    objects=[
        (&quot;model&quot;, &quot;simple&quot;),
        (&quot;temporal_block&quot;, &quot;hourly&quot;),
        (&quot;temporal_block&quot;, &quot;2hourly&quot;),
        (&quot;temporal_block&quot;, &quot;3hourly&quot;),
        (&quot;stochastic_scenario&quot;, &quot;realisation&quot;),
        (&quot;stochastic_scenario&quot;, &quot;forecast1&quot;),
        (&quot;stochastic_scenario&quot;, &quot;forecast2&quot;),
        (&quot;stochastic_structure&quot;, &quot;one_stage&quot;),
        (&quot;stochastic_structure&quot;, &quot;two_stage&quot;),
        (&quot;unit&quot;, &quot;pwrplant&quot;),
        (&quot;node&quot;, &quot;fuel&quot;),
        (&quot;node&quot;, &quot;elec&quot;),
    ],
    relationships=[
        (&quot;parent_stochastic_scenario__child_stochastic_scenario&quot;, (&quot;realisation&quot;, &quot;forecast1&quot;)),
        (&quot;parent_stochastic_scenario__child_stochastic_scenario&quot;, (&quot;realisation&quot;, &quot;forecast2&quot;)),
        (&quot;stochastic_structure__stochastic_scenario&quot;, (&quot;one_stage&quot;, &quot;realisation&quot;)),
        (&quot;stochastic_structure__stochastic_scenario&quot;, (&quot;two_stage&quot;, &quot;realisation&quot;)),
        (&quot;stochastic_structure__stochastic_scenario&quot;, (&quot;two_stage&quot;, &quot;forecast1&quot;)),
        (&quot;stochastic_structure__stochastic_scenario&quot;, (&quot;two_stage&quot;, &quot;forecast2&quot;)),
        (&quot;unit__from_node&quot;, (&quot;pwrplant&quot;, &quot;fuel&quot;)),
        (&quot;unit__to_node&quot;, (&quot;pwrplant&quot;, &quot;elec&quot;)),
        (&quot;node__temporal_block&quot;, (&quot;fuel&quot;, &quot;3hourly&quot;)),
        (&quot;node__temporal_block&quot;, (&quot;elec&quot;, &quot;hourly&quot;)),
        (&quot;units_on__temporal_block&quot;, (&quot;pwrplant&quot;, &quot;2hourly&quot;)),
        (&quot;node__stochastic_structure&quot;, (&quot;fuel&quot;, &quot;one_stage&quot;)),
        (&quot;node__stochastic_structure&quot;, (&quot;elec&quot;, &quot;two_stage&quot;)),
        (&quot;units_on__stochastic_structure&quot;, (&quot;pwrplant&quot;, &quot;one_stage&quot;)),
    ],
    object_parameter_values=[
        (&quot;model&quot;, &quot;simple&quot;, &quot;model_start&quot;, unparse_db_value(DateTime(&quot;2023-01-01T00:00&quot;))),
        (&quot;model&quot;, &quot;simple&quot;, &quot;model_end&quot;, unparse_db_value(DateTime(&quot;2023-01-01T06:00&quot;))),
        (&quot;temporal_block&quot;, &quot;hourly&quot;, &quot;resolution&quot;, unparse_db_value(Hour(1))),
        (&quot;temporal_block&quot;, &quot;2hourly&quot;, &quot;resolution&quot;, unparse_db_value(Hour(2))),
        (&quot;temporal_block&quot;, &quot;3hourly&quot;, &quot;resolution&quot;, unparse_db_value(Hour(3))),
        (&quot;temporal_block&quot;, &quot;hourly&quot;, &quot;block_end&quot;, unparse_db_value(DateTime(&quot;2023-01-01T09:00&quot;))),
    ],
    relationship_parameter_values=[
        (
            &quot;stochastic_structure__stochastic_scenario&quot;,
            (&quot;two_stage&quot;, &quot;realisation&quot;),
            &quot;stochastic_scenario_end&quot;,
            unparse_db_value(Hour(6))
        ),
        (&quot;unit__from_node&quot;, (&quot;pwrplant&quot;, &quot;fuel&quot;), &quot;unit_capacity&quot;, 200),
        (&quot;unit__to_node&quot;, (&quot;pwrplant&quot;, &quot;elec&quot;), &quot;unit_capacity&quot;, 100),
        (&quot;unit__to_node&quot;, (&quot;pwrplant&quot;, &quot;elec&quot;), &quot;shut_down_limit&quot;, 0.2),
    ],
)</code></pre><p>Whoa, what&#39;s all that stuff!?</p><p>Basically, what we&#39;re doing here is creating a SpineOpt <a href="../../concept_reference/Object Classes/#model">model</a> called <code>simple</code>, starting January first 2023 at 00:00 and ending at 06:00. This <code>simple</code> <a href="../../concept_reference/Object Classes/#model">model</a> has three <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a>s, <code>1hourly</code>, <code>2hourly</code> and <code>3hourly</code>, with one-, two-, and three-hour resolution respectively; and <code>1hourly</code> ends at 09:00 (three hours later than the <a href="../../concept_reference/Object Classes/#model">model</a> - so it&#39;s like a look-ahead). It also has three <a href="../../concept_reference/Object Classes/#stochastic_scenario">stochastic_scenario</a>s, <code>realisation</code>, <code>forecast1</code> and <code>forecast2</code>, where the two latter are children of the former; and two <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a>s, <code>one_stage</code>, including only <code>realisation</code>, and <code>two_stage</code>, including all three of them and with <code>realisation</code> ending 6 hours after the model starts.</p><p>The <a href="../../concept_reference/Object Classes/#model">model</a> consists of two <a href="../../concept_reference/Object Classes/#node">node</a>s, <code>fuel</code> and <code>elec</code>, with a <a href="../../concept_reference/Object Classes/#unit">unit</a> in between, <code>pwrplant</code>. The <code>fuel</code> <a href="../../concept_reference/Object Classes/#node">node</a> is modelled at three-hour resolution and one-stage stochastics; the <code>elec</code> <a href="../../concept_reference/Object Classes/#node">node</a> is modelled at one-hour resolution and two-stage stochastics; and the <code>pwrplant</code> <a href="../../concept_reference/Object Classes/#unit">unit</a> is modelled at two-hour resolution and one-stage stochastics. Finally, the <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> is 200 for flows coming to the <code>pwrplant</code> from the <code>fuel</code> <a href="../../concept_reference/Object Classes/#node">node</a>, and 300 for flows going from the <code>pwrplant</code> to the <code>elec</code> <a href="../../concept_reference/Object Classes/#node">node</a>; the <a href="../../concept_reference/Parameters/#shut_down_limit">shut_down_limit</a> is 0.2 for the <code>elec</code> <a href="../../concept_reference/Object Classes/#node">node</a> flows (and none, thus irrestricted, for the <code>fuel</code> <a href="../../concept_reference/Object Classes/#node">node</a> flows).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you have trouble understanding the above, maybe (unfortunately) it means you&#39;re not quite ready yet to write your own constraints in SpineOpt. My suggestion would be to go through the different tutorials and come back after that.</p></div></div><h3 id="The-actual-constraint-code"><a class="docs-heading-anchor" href="#The-actual-constraint-code">The actual constraint code</a><a id="The-actual-constraint-code-1"></a><a class="docs-heading-anchor-permalink" href="#The-actual-constraint-code" title="Permalink"></a></h3><p>I guess it&#39;s about time we finally start writing our constraint. We will split our code in two functions:</p><ul><li>A function that receives a JuMP <code>Model</code> object <code>m</code> and returns an <code>Array</code> containing all the constraint indices.</li><li>A function that receives a JuMP <code>Model</code> object <code>m</code> and adds the constraint to it.</li></ul><p>Let&#39;s start with dummy versions of these functions so we can appreciate the infrastructure:</p><pre><code class="language-julia hljs">using JuMP

function my_unit_flow_capacity_constraint_indices(m)
    []
end

function add_my_unit_flow_capacity_constraint!(m)
    m.ext[:spineopt].constraints[:my_unit_flow_capacity] = Dict(
        ind =&gt; @constraint(m, 0 &lt;= 0)
        for ind in my_unit_flow_capacity_constraint_indices(m)
    )
end</code></pre><p>The <code>my_unit_flow_capacity_constraint_indices</code> is at the moment returning no indices. Then, for each of those indices (!), <code>add_my_unit_flow_capacity_constraint</code> is creating the constraint <code>0 &lt;= 0</code> and adding it to the model. So yeah, not very useful, but probably good enough to get started.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In <code>add_my_unit_flow_capacity_constraint!</code>, the part that adds the constraint to the model is just the <code>@constraint(m, ...)</code> bit. The rest of the machinery is mainly for inspection purposes. We build a dictionary that maps each constraint index to the corresponding constraint, and store that dictionary in a specific location within the <code>m.ext</code> dictionary. Whit this we can easily access the generated constraints via the model object <code>m</code> that gets returned by <code>run_spineopt</code>.</p></div></div><h4 id="The-function-that-yields-the-constraint-indices"><a class="docs-heading-anchor" href="#The-function-that-yields-the-constraint-indices">The function that yields the constraint indices</a><a id="The-function-that-yields-the-constraint-indices-1"></a><a class="docs-heading-anchor-permalink" href="#The-function-that-yields-the-constraint-indices" title="Permalink"></a></h4><h5 id="Space"><a class="docs-heading-anchor" href="#Space">Space</a><a id="Space-1"></a><a class="docs-heading-anchor-permalink" href="#Space" title="Permalink"></a></h5><p>Let&#39;s develop <code>my_unit_flow_capacity_constraint_indices</code> so it returns at least something. Let&#39;s make it return the &#39;spatial&#39; indices.</p><p>We will start very slow. We are looking for the tuples of <a href="../../concept_reference/Object Classes/#unit">unit</a> and <a href="../../concept_reference/Object Classes/#node">node</a> associated via <a href="../../concept_reference/Relationship Classes/#unit__from_node">unit__from_node</a> and/or <a href="../../concept_reference/Relationship Classes/#unit__to_node">unit__to_node</a> for which <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> is specified.</p><p>So we could try something like this:</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [(unit=u, node=n, direction=d) for (u, n, d) in unit__from_node()]
end</code></pre><p>Will the above work? Well, it&#39;s only considering flows <em>from</em> a <a href="../../concept_reference/Object Classes/#node">node</a> to a <a href="../../concept_reference/Object Classes/#unit">unit</a>. We also need the flows in the opposite direction. Let&#39;s try again:</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d)
        for (u, n, d) in vcat(unit__from_node(), unit__to_node())
    ]
end</code></pre><p>That seems better. We are concatenating the output of <code>unit__from_node()</code> and <code>unit__to_node()</code> using Julia&#39;s <code>vcat</code> function. But we also need to make sure that the <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> is specified for our <a href="../../concept_reference/Object Classes/#unit">unit</a>/<a href="../../concept_reference/Object Classes/#node">node</a>(/<code>direction</code>) combination. So we need to add a condition to our array comprehension:</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d)
        for (u, n, d) in vcat(unit__from_node(), unit__to_node())
        if unit_capacity(unit=u, node=n, direction=d) != nothing
    ]
end</code></pre><p>That should work.</p><p>So we have a function that returns the &#39;spatial&#39; indices! We can still do a little better than that though. Turns out this kind of computation is so common, that we have a SpineInterface function that can be used as a shortcut, called <code>indices</code>. The above can be rewritten simply as:</p><pre><code class="language-julia hljs">using SpineInterface

function my_unit_flow_capacity_constraint_indices(m)
    [(unit=u, node=n, direction=d) for (u, n, d) in indices(unit_capacity)]
end</code></pre><p>So let&#39;s see what&#39;s happening!</p><h6 id="the_code_that_shows"><a class="docs-heading-anchor" href="#the_code_that_shows">The code that shows the constraints being generated</a><a id="the_code_that_shows-1"></a><a class="docs-heading-anchor-permalink" href="#the_code_that_shows" title="Permalink"></a></h6><p>The <code>run_spineopt</code> function has an optional keyword argument called <code>add_constraints</code> that we can use to try out our constraint code. Basically, if we give this argument a function, the function will be called with the model object at the moment of adding constraints. So we can try giving it the <code>add_my_unit_flow_capacity_constraint!</code> function:</p><pre><code class="language-julia hljs">using SpineOpt

m = run_spineopt(
    url_in,
    nothing;
    add_constraints=add_my_unit_flow_capacity_constraint!,
    optimize=false,
    log_level=0,
)

my_unit_flow_capacity_constraint = m.ext[:spineopt].constraints[:my_unit_flow_capacity]
for k in sort(collect(keys(my_unit_flow_capacity_constraint)))
    println(my_unit_flow_capacity_constraint[k])
end</code></pre><p>Note that we are also passing <code>nothing</code> as the second argument (the output URL), because we don&#39;t want to write results. In fact, we don&#39;t even want to solve (<code>optimize=false</code>), we are just interested in inspecting our constraint. We also aren&#39;t very interested in the log (<code>log_level=0</code>).</p><p>And after that, we are just printing all the constraints that got generated ordered by index. At the moment it should be printing:</p><pre><code class="nohighlight hljs">my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node) : 0 ≤ 0</code></pre><p>which (I hope you agree) means we&#39;re good.</p><h5 id="Time"><a class="docs-heading-anchor" href="#Time">Time</a><a id="Time-1"></a><a class="docs-heading-anchor-permalink" href="#Time" title="Permalink"></a></h5><p>Let&#39;s add the &#39;temporal&#39; indices. We know that we need two of such indices: the <em>current</em> time-slice, and the <em>next</em> time-slice. The <em>current</em> time-slice we will use to access both <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> and <a href="../../mathematical_formulation/variables/#units_on">units_on</a>, and the <em>next</em> to access <a href="../../mathematical_formulation/variables/#units_shut_down">units_shut_down</a>.</p><p>To collect time-slices, we will be using a special function from SpineOpt called <code>time_slice</code>. This function receives a model object <code>m</code> and returns an array with all the time-slices in that model - but it also has two optional keyword arguments, <code>temporal_block</code> and <code>t</code>, to filter the result.</p><ul><li>If you specify <code>temporal_block</code> as a <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a> or array of <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a>s, you get only time-slices in those blocks.</li><li>If you specify <code>t</code> as a time-slice or array of time-slices, you get only those time-slices (if they also pass the <code>temporal_block</code> filter above.)</li></ul><p>So let&#39;s try and find our <em>current</em> time-slice. Let&#39;s start simple. Let&#39;s begin by taking only the time-slices associated to the <a href="../../concept_reference/Object Classes/#unit">unit</a>.</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d, t=t)
        for (u, n, d) in indices(unit_capacity)
        for t in time_slice(m; temporal_block=units_on__temporal_block(unit=u))
    ]
end</code></pre><p>Let&#39;s see. We first call <code>units_on__temporal_block</code> while passing our <a href="../../concept_reference/Object Classes/#unit">unit</a> &#39;spatial&#39; index <code>u</code>, via the <code>unit</code> argument. This returns an <code>Array</code> with the <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a>s associated to that <a href="../../concept_reference/Object Classes/#unit">unit</a>, that we then pass to the <code>time_slice</code> function via the <code>temporal_block</code> argument. So we end up obtaining all the time-slices in <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a>s associated to <code>u</code>.</p><p>If we rerun <a href="#the_code_that_shows">the code that shows the constraints</a>, we see the following:</p><pre><code class="language-julia hljs">my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T00:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T02:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T04:00~&gt;2023-01-01T06:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T00:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T02:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T04:00~&gt;2023-01-01T06:00) : 0 ≤ 0</code></pre><p>So we are getting time-slices at two-hour resolution. This makes sense, because the <code>pwrplant</code> <a href="../../concept_reference/Object Classes/#unit">unit</a> is (only) associated to the <code>2hourly</code> <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a>, remember? However, does it work? Well, we know the <code>elec</code> <a href="../../concept_reference/Object Classes/#node">node</a> is associated to the <code>1hourly</code> <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a>, and that means we have <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> variables at one-hour resolution - because <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> gets its resolution from the <a href="../../concept_reference/Object Classes/#node">node</a>, right? We can&#39;t just enforce the constraint every two hours if the flows are tracked every <em>one</em> hour!</p><p>So taking the time-slices of the <a href="../../concept_reference/Object Classes/#unit">unit</a> is clearly insufficient, because we happen to have a <a href="../../concept_reference/Object Classes/#node">node</a> at a higher resolution.</p><p>Let&#39;s try to take the time-slices of the <a href="../../concept_reference/Object Classes/#node">node</a> then:</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d, t=t)
        for (u, n, d) in indices(unit_capacity)
        for t in time_slice(m; temporal_block=node__temporal_block(node=n))
    ]
end</code></pre><p>After running <a href="#the_code_that_shows">the code that shows the constraints</a>, we observe:</p><pre><code class="nohighlight hljs">my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T00:00~&gt;2023-01-01T01:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T01:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T02:00~&gt;2023-01-01T03:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T03:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T04:00~&gt;2023-01-01T05:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T05:00~&gt;2023-01-01T06:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T06:00~&gt;2023-01-01T07:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T07:00~&gt;2023-01-01T08:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T08:00~&gt;2023-01-01T09:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T00:00~&gt;2023-01-01T03:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T03:00~&gt;2023-01-01T06:00) : 0 ≤ 0</code></pre><p>So now we&#39;re getting time-slices at one-hour resolution on the <code>elec</code> side, and three-hour on the <code>fuel</code> side. This seems enough to enforce that the <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> is never higher than the <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>. However, we also need to enforce that the <a href="../../mathematical_formulation/variables/#unit_flow">unit_flow</a> is never higher than the <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> times the <a href="../../concept_reference/Parameters/#shut_down_limit">shut_down_limit</a> if the unit is shutting down the next period. Since the unit is able to shut-down &#39;at two-hour resolution&#39; so to say, clearly taking the three-hour resolution on the <code>fuel</code> side is not enough to check if the <a href="../../concept_reference/Object Classes/#unit">unit</a> is shutting down in the next period. Worst-case scenario, the <a href="../../concept_reference/Object Classes/#unit">unit</a> could be shutting down in the <em>current</em> period, because the current period lasts three hours and the <a href="../../concept_reference/Object Classes/#unit">unit</a> can shut down after two hours!</p><p>So it looks like we need to take the time-slices from the <a href="../../concept_reference/Object Classes/#unit">unit</a> <em>and</em> the <a href="../../concept_reference/Object Classes/#node">node</a>. We could do it this way:</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d, t=t)
        for (u, n, d) in indices(unit_capacity)
        for t in time_slice(
            m; temporal_block=vcat(node__temporal_block(node=n), units_on__temporal_block(unit=u))
        )
    ]
end</code></pre><p>Here, we are concatenating the result of <code>node__temporal_block(...)</code> and <code>units_on__temporal_block(...)</code> using <code>vcat</code>, and passing the result to <code>time_slice</code>. The final result, then, is the time-slices associated with either the <a href="../../concept_reference/Object Classes/#unit">unit</a> &#39;spatial&#39; index <code>u</code>, the <a href="../../concept_reference/Object Classes/#node">node</a> &#39;spatial&#39; index <code>n</code>, or both.</p><p>Let&#39;s check by re-running <a href="#the_code_that_shows">the code that shows the constraints</a>:</p><pre><code class="language-julia hljs">my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T00:00~&gt;2023-01-01T01:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T00:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T01:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T02:00~&gt;2023-01-01T03:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T02:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T03:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T04:00~&gt;2023-01-01T05:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T04:00~&gt;2023-01-01T06:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T05:00~&gt;2023-01-01T06:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T06:00~&gt;2023-01-01T07:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T07:00~&gt;2023-01-01T08:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T08:00~&gt;2023-01-01T09:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T00:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T00:00~&gt;2023-01-01T03:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T02:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T03:00~&gt;2023-01-01T06:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T04:00~&gt;2023-01-01T06:00) : 0 ≤ 0</code></pre><p>Now we are getting a lot of time-slices! On the <code>elec</code> side, we get both time-slices at one- and two-hour resolution. On the <code>fuel</code> side, we get both at two- and three-. We shouldn&#39;t be applying the constraint more than once for the same period of time, for efficiency - so we should just take the ones with the <em>highest</em> resolution.</p><p>Let&#39;s try again:</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d, t=t)
        for (u, n, d) in indices(unit_capacity)
        for t in t_highest_resolution(
            time_slice(
                m; temporal_block=vcat(node__temporal_block(node=n), units_on__temporal_block(unit=u))
            )
        )
    ]
end</code></pre><p>Here we are using a function from SpineInterface called <code>t_highest_resolution</code>. This function takes an <code>Array</code> of time-slices and returns another <code>Array</code> only with the ones that don&#39;t contain any other - i.e., the ones with the highest resolution.</p><p>Let&#39;s see what we get by running <a href="#the_code_that_shows">the code that shows the constraints</a>:</p><pre><code class="language-julia hljs">my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T00:00~&gt;2023-01-01T01:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T01:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T02:00~&gt;2023-01-01T03:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T03:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T04:00~&gt;2023-01-01T05:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T05:00~&gt;2023-01-01T06:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T06:00~&gt;2023-01-01T07:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T07:00~&gt;2023-01-01T08:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T08:00~&gt;2023-01-01T09:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T00:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T02:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T04:00~&gt;2023-01-01T06:00) : 0 ≤ 0</code></pre><p>Ah, that looks a lot better! We are getting one-hour on the <code>elec</code> side, and two-hour on the <code>fuel</code> side. I&#39;m pretty sure that&#39;s exactly what we want!</p><p>So we have found the <em>current</em> time-slice - now let&#39;s find the <em>next</em> one.</p><p>For this we will use a special function from SpineOpt called <code>t_before_t</code>. This function is mainly intended to be called while specifying one of its two keyword arguments, <code>t_before</code> or <code>t_after</code>, with some time-slice.</p><ul><li>If you specify <code>t_before</code>, you get all the time-slices that <em>start</em> when the given time-slice <em>ends</em>.</li><li>If you specify <code>t_after</code>, you get all the time-slices that <em>end</em> when the given one <em>starts</em>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You might be asking yourself, how could there be more than one time-slice starting when another one ends, or ending when another one starts? Well, simply because in SpineOpt we can have multiple <a href="../../concept_reference/Object Classes/#temporal_block">temporal_block</a>s defined over the same period of time, with different resolutions - so time-slices of those blocks will simply overlap. Therefore, there might be multiple time-slices starting at the same time, and also multiple ones ending at the same time.</p></div></div><p>So let&#39;s use <code>t_before_t</code> to try and compute the <em>next</em> time-slices for our constraint. We know that the <em>next</em> time-slice should come from the same set as the <em>current</em>, that is, the highest-resolution time-slices associated to the <a href="../../concept_reference/Object Classes/#unit">unit</a> and/or the <a href="../../concept_reference/Object Classes/#node">node</a>. But the <em>next</em> should also come <em>after</em> the <em>current</em>. So basically we can try something like this:</p><pre><code class="language-julia hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d, t=t, t_next=t_next)
        for (u, n, d) in indices(unit_capacity)
        for t in t_highest_resolution(
            time_slice(
                m; temporal_block=vcat(node__temporal_block(node=n), units_on__temporal_block(unit=u))
            )
        )
        for t_next in t_highest_resolution(
            time_slice(
                m;
                temporal_block=vcat(node__temporal_block(node=n), units_on__temporal_block(unit=u)),
                t=t_before_t(m; t_before=t),
            )
        )
    ]
end</code></pre><p>Let&#39;s unpack the last call to <code>time_slice</code> above (the one that we iterate to obtain <code>t_next</code>). Basically, we&#39;re doing almost exactly the same as we do to obtain the current time-slice, <code>t</code>  (that is, calling <code>time_slice</code> by specifying the <code>temporal_block</code> argument so we only get time-slices associated to our <a href="../../concept_reference/Object Classes/#unit">unit</a> <code>u</code> and/or our <a href="../../concept_reference/Object Classes/#node">node</a> <code>n</code>). Except that on top of that, we are also specifying the <code>t</code> argument so we only get time-slices that start when our current &#39;temporal&#39; index <code>t</code> ends - as obtained with <code>t_before_t</code>.</p><p>This should work, right? Well, let&#39;s run <a href="#the_code_that_shows">the code that shows the constraints</a> again to see what happens:</p><pre><code class="language-julia hljs">my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T00:00~&gt;2023-01-01T01:00, t_next = 2023-01-01T01:00~&gt;2023-01-01T02:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T01:00~&gt;2023-01-01T02:00, t_next = 2023-01-01T02:00~&gt;2023-01-01T03:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T02:00~&gt;2023-01-01T03:00, t_next = 2023-01-01T03:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T03:00~&gt;2023-01-01T04:00, t_next = 2023-01-01T04:00~&gt;2023-01-01T05:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T04:00~&gt;2023-01-01T05:00, t_next = 2023-01-01T05:00~&gt;2023-01-01T06:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T05:00~&gt;2023-01-01T06:00, t_next = 2023-01-01T06:00~&gt;2023-01-01T07:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T06:00~&gt;2023-01-01T07:00, t_next = 2023-01-01T07:00~&gt;2023-01-01T08:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T07:00~&gt;2023-01-01T08:00, t_next = 2023-01-01T08:00~&gt;2023-01-01T09:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T00:00~&gt;2023-01-01T02:00, t_next = 2023-01-01T02:00~&gt;2023-01-01T04:00) : 0 ≤ 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T02:00~&gt;2023-01-01T04:00, t_next = 2023-01-01T04:00~&gt;2023-01-01T06:00) : 0 ≤ 0</code></pre><p>Beautiful. It looks like we have found our &#39;temporal&#39; indices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Have we? Well, almost. You may have noticed that after adding the <code>t_next</code> component, we end up having fewer indices in total. Indeed, we are now missing the ones where <code>t</code> (the <em>current</em> time slice) was <code>2023-01-01T08:00~&gt;2023-01-01T09:00</code> and <code>2023-01-01T04:00~&gt;2023-01-01T06:00</code>. Why is that? Well, simply because at <code>2023-01-01T09:00</code> the <code>1hourly</code> block ends, and at <code>2023-01-01T06:00</code> the model ends - so there are no time-slices after that. In this case, <code>t_before_t</code> just returns an empty array and <code>my_unit_flow_capacity_constraint_indices</code>  doesn&#39;t find any <code>t_next</code> to iterate over. We should remediate this, but we won&#39;t do it immediately. We will save it for the very last, because it really doesn&#39;t stop us from progressing and might be a little bit distracting to do right now. Trust me, we will figure it out.</p></div></div><h5 id="Stochastics"><a class="docs-heading-anchor" href="#Stochastics">Stochastics</a><a id="Stochastics-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastics" title="Permalink"></a></h5><p>On to compute our &#39;stochastic&#39; indices.</p><p>We said above that each of these indices will be a path in the stochastic scenario DAG associated to our &#39;spatial&#39; indices, that covers the time-slices from our &#39;temporal&#39; indices.</p><p>Ok, so how do we find the paths? We will be using a convenience function from SpineOpt called <code>active_stochastic_paths</code>. The method we will use receives a model object <code>m</code> and two mandatory keyword arguments, <code>stochastic_structure</code> and <code>t</code>, the former expecting a <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a> or <code>Array</code> of <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a>s, and the latter a time-slice or <code>Array</code> of time-slices. The method returns all the stochastic paths in the <a href="../../concept_reference/Object Classes/#stochastic_scenario">stochastic_scenario</a> DAG subsets corresponding to the given <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a>s, where the given time slices exist. We can use it as follows:</p><pre><code class="nohighlight hljs">function my_unit_flow_capacity_constraint_indices(m)
    [
        (unit=u, node=n, direction=d, t=t, t_next=t_next, s_path=s_path)
        for (u, n, d) in indices(unit_capacity)
        for t in t_highest_resolution(
            time_slice(
                m; temporal_block=vcat(node__temporal_block(node=n), units_on__temporal_block(unit=u))
            )
        )
        for t_next in t_highest_resolution(
            time_slice(
                m;
                temporal_block=vcat(node__temporal_block(node=n), units_on__temporal_block(unit=u)),
                t=t_before_t(m; t_before=t),
            )
        )
        for s_path in active_stochastic_paths(
            m,
            stochastic_structure=vcat(
                node__stochastic_structure(node=n), units_on__stochastic_structure(unit=u)
            ),
            t=[t, t_next]
        )
    ]
end</code></pre><p>And if we run <a href="#the_code_that_shows">the code that shows the constraints</a>, we get:</p><pre><code class="language-julia hljs">my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T00:00~&gt;2023-01-01T01:00, t_next = 2023-01-01T01:00~&gt;2023-01-01T02:00, s_path = Object[realisation]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T01:00~&gt;2023-01-01T02:00, t_next = 2023-01-01T02:00~&gt;2023-01-01T03:00, s_path = Object[realisation]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T02:00~&gt;2023-01-01T03:00, t_next = 2023-01-01T03:00~&gt;2023-01-01T04:00, s_path = Object[realisation]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T03:00~&gt;2023-01-01T04:00, t_next = 2023-01-01T04:00~&gt;2023-01-01T05:00, s_path = Object[realisation]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T04:00~&gt;2023-01-01T05:00, t_next = 2023-01-01T05:00~&gt;2023-01-01T06:00, s_path = Object[realisation]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T05:00~&gt;2023-01-01T06:00, t_next = 2023-01-01T06:00~&gt;2023-01-01T07:00, s_path = Object[realisation, forecast1]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T05:00~&gt;2023-01-01T06:00, t_next = 2023-01-01T06:00~&gt;2023-01-01T07:00, s_path = Object[realisation, forecast2]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T06:00~&gt;2023-01-01T07:00, t_next = 2023-01-01T07:00~&gt;2023-01-01T08:00, s_path = Object[realisation, forecast1]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T06:00~&gt;2023-01-01T07:00, t_next = 2023-01-01T07:00~&gt;2023-01-01T08:00, s_path = Object[realisation, forecast2]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T07:00~&gt;2023-01-01T08:00, t_next = 2023-01-01T08:00~&gt;2023-01-01T09:00, s_path = Object[realisation, forecast1]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = elec, direction = to_node, t = 2023-01-01T07:00~&gt;2023-01-01T08:00, t_next = 2023-01-01T08:00~&gt;2023-01-01T09:00, s_path = Object[realisation, forecast2]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T00:00~&gt;2023-01-01T02:00, t_next = 2023-01-01T02:00~&gt;2023-01-01T04:00, s_path = Object[realisation]) : 0 = 0
my_unit_flow_capacity(unit = pwrplant, node = fuel, direction = from_node, t = 2023-01-01T02:00~&gt;2023-01-01T04:00, t_next = 2023-01-01T04:00~&gt;2023-01-01T06:00, s_path = Object[realisation]) : 0 = 0
</code></pre><p>Which looks like we&#39;re on to something. Indeed, on the <code>fuel</code> side, <code>s_path</code> is always just <code>[realisation]</code>, because both the <code>fuel</code> <a href="../../concept_reference/Object Classes/#node">node</a> and the <code>pwrplant</code> <a href="../../concept_reference/Object Classes/#unit">unit</a> have the <code>one_stage</code> <a href="../../concept_reference/Object Classes/#stochastic_structure">stochastic_structure</a>. But on the <code>elec</code> side, at the beginning we have <code>[realisation]</code> and then we start getting <code>[realisation, forecast1]</code> and <code>[realisation, forecast2]</code>. The turning point is exactly at <code>2023-01-01T06:00</code>, where <code>realisation</code> ends according to the <a href="../../concept_reference/Parameters/#stochastic_scenario_end">stochastic_scenario_end</a> parameter.</p><p>So it&#39;s all good!</p><h4 id="The-function-that-generates-the-constraint"><a class="docs-heading-anchor" href="#The-function-that-generates-the-constraint">The function that generates the constraint</a><a id="The-function-that-generates-the-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#The-function-that-generates-the-constraint" title="Permalink"></a></h4><p>Congratulations, you have made it this far. Now we will finally start writing our constraint expression.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>I will grab a coffee and be right back.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../how_does_the_model_update_itself/">« How does the model update itself</a><a class="docs-footer-nextpage" href="../time_slices/">Time slices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 28 February 2024 16:14">Wednesday 28 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
