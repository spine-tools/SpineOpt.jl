<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · SpineOpt.jl</title><meta name="title" content="Constraints · SpineOpt.jl"/><meta property="og:title" content="Constraints · SpineOpt.jl"/><meta property="twitter:title" content="Constraints · SpineOpt.jl"/><meta name="description" content="Documentation for SpineOpt.jl."/><meta property="og:description" content="Documentation for SpineOpt.jl."/><meta property="twitter:description" content="Documentation for SpineOpt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SpineOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpineOpt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/recommended_workflow/">Recommended workflow</a></li><li><a class="tocitem" href="../../getting_started/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorial/webinars/">Webinars and examples</a></li><li><a class="tocitem" href="../../tutorial/simple_system/">Simple system</a></li><li><a class="tocitem" href="../../tutorial/temporal_resolution/">Temporal resolution</a></li><li><a class="tocitem" href="../../tutorial/stochastic_system/">Stochastic structure</a></li><li><a class="tocitem" href="../../tutorial/capacity_planning/">Capacity planning</a></li><li><a class="tocitem" href="../../tutorial/multi-year_investment/">Multi-year investments using economic parameters</a></li><li><a class="tocitem" href="../../tutorial/reserves/">Reserve requirements</a></li><li><a class="tocitem" href="../../tutorial/ramping/">Ramping constraints</a></li><li><a class="tocitem" href="../../tutorial/unit_commitment/">Unit Commitment</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../how_to/change_the_solver/">Change the solver</a></li><li><a class="tocitem" href="../../how_to/compile_julia_system_image/">Compile julia system image</a></li><li><a class="tocitem" href="../../how_to/define_an_efficiency/">Define an efficiency</a></li><li><a class="tocitem" href="../../how_to/impose_renewable_energy_targets/">Impose renewable energy targets</a></li><li><a class="tocitem" href="../../how_to/manage_output/">Manage output</a></li><li><a class="tocitem" href="../../how_to/model_hydro_power_coupling/">Model hydro power coupling</a></li><li><a class="tocitem" href="../../how_to/print_the_model/">Print the model</a></li><li><a class="tocitem" href="../../how_to/set_up_representative_days_for_investment_problems/">Set up representative days for investment problems</a></li></ul></li><li><span class="tocitem">Database structure</span><ul><li><a class="tocitem" href="../../concept_reference/the_basics/">Basics of the data structure</a></li><li><a class="tocitem" href="../../concept_reference/archetypes/">Archetypes</a></li></ul></li><li><span class="tocitem">Standard model framework</span><ul><li><a class="tocitem" href="../../advanced_concepts/temporal_framework/">Temporal Framework</a></li><li><a class="tocitem" href="../../advanced_concepts/stochastic_framework/">Stochastic Framework</a></li></ul></li><li><span class="tocitem">Standard model features</span><ul><li><a class="tocitem" href="../../advanced_concepts/unit_commitment/">Unit Commitment</a></li><li><a class="tocitem" href="../../advanced_concepts/investment_optimization/">Investment Optimization</a></li><li><a class="tocitem" href="../../advanced_concepts/reserves/">Reserves</a></li><li><a class="tocitem" href="../../advanced_concepts/ramping/">Ramping</a></li><li><a class="tocitem" href="../../advanced_concepts/Lossless_DC_power_flow/">Lossless nodal DC power flows</a></li><li><a class="tocitem" href="../../advanced_concepts/powerflow/">PTDF-Based Powerflow</a></li><li><a class="tocitem" href="../../advanced_concepts/pressure_driven_gas_transfer/">Pressure driven gas transfer</a></li><li><a class="tocitem" href="../../advanced_concepts/user_constraints/">User Constraints</a></li></ul></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../../advanced_concepts/decomposition/">Decomposition</a></li><li><a class="tocitem" href="../../advanced_concepts/mga/">Modelling to generate alternatives</a></li><li><a class="tocitem" href="../../advanced_concepts/multi_stage/">Multi-stage optimisation</a></li></ul></li><li><span class="tocitem">SpineOpt Template</span><ul><li><a class="tocitem" href="../../concept_reference/Object Classes/">Object Classes</a></li><li><a class="tocitem" href="../../concept_reference/Relationship Classes/">Relationship Classes</a></li><li><a class="tocitem" href="../../concept_reference/Parameters/">Parameters</a></li><li><a class="tocitem" href="../../concept_reference/Parameter Value Lists/">Parameter Value Lists</a></li></ul></li><li><span class="tocitem">Mathematical Formulation</span><ul><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../objective_function/">Objective</a></li><li class="is-active"><a class="tocitem" href>Constraints</a><ul class="internal"><li><a class="tocitem" href="#Balance-constraint"><span>Balance constraint</span></a></li><li><a class="tocitem" href="#Unit-operation"><span>Unit operation</span></a></li><li><a class="tocitem" href="#Network-constraints"><span>Network constraints</span></a></li><li><a class="tocitem" href="#Investments"><span>Investments</span></a></li><li><a class="tocitem" href="#User-constraints"><span>User constraints</span></a></li><li><a class="tocitem" href="#benders_decomposition"><span>Benders decomposition</span></a></li></ul></li></ul></li><li><span class="tocitem">Implementation details</span><ul><li><a class="tocitem" href="../../implementation_details/documentation/">Documentation</a></li><li><a class="tocitem" href="../../implementation_details/how_does_the_model_update_itself/">How does the model update itself</a></li><li><a class="tocitem" href="../../implementation_details/how_to_write_a_constraint/">How to write a constraint</a></li><li><a class="tocitem" href="../../implementation_details/time_slices/">Time slices</a></li></ul></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Formulation</a></li><li class="is-active"><a href>Constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constraints</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/spine-tools/SpineOpt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/spine-tools/SpineOpt.jl/blob/master/docs/src/mathematical_formulation/constraints_automatically_generated.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h1><h2 id="Balance-constraint"><a class="docs-heading-anchor" href="#Balance-constraint">Balance constraint</a><a id="Balance-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Balance-constraint" title="Permalink"></a></h2><h3 id="constraint_nodal_balance"><a class="docs-heading-anchor" href="#constraint_nodal_balance">Nodal balance</a><a id="constraint_nodal_balance-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_nodal_balance" title="Permalink"></a></h3><p>In <strong>SpineOpt</strong>, <a href="../../concept_reference/Object Classes/#node">node</a> is the place where an energy balance is enforced. As universal aggregators, they are the glue that brings all components of the energy system together. An energy balance is created for each <a href="../../concept_reference/Object Classes/#node">node</a> for all <code>node_stochastic_time_indices</code>, unless the <a href="../../concept_reference/Parameters/#balance_type">balance_type</a> parameter of the node takes the value <a href="../../concept_reference/Parameter Value Lists/#balance_type_list">balance_type_none</a> or if the node in question is a member of a node group, for which the <a href="../../concept_reference/Parameters/#balance_type">balance_type</a> is <a href="../../concept_reference/Parameter Value Lists/#balance_type_list">balance_type_group</a>. The parameter <a href="../../concept_reference/Parameters/#nodal_balance_sense">nodal_balance_sense</a> defaults to equality, but can be changed to allow overproduction (<a href="../../concept_reference/Parameters/#nodal_balance_sense">nodal_balance_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&gt;=</code></a>) or underproduction (<a href="../../concept_reference/Parameters/#nodal_balance_sense">nodal_balance_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&lt;=</code></a>). The energy balance is enforced by the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; v^{node\_injection}_{(n,s,t)}
+ \sum_{
        conn
}
v^{connection\_flow}_{(conn,n,to\_node,s,t)}
- \sum_{
        conn
}
v^{connection\_flow}_{(conn,n,from\_node,s,t)} \\
&amp; \begin{cases}
\ge &amp; \text{if } p^{nodal\_balance\_sense} = &quot;&gt;=&quot; \\
= &amp; \text{if } p^{nodal\_balance\_sense} = &quot;==&quot; \\
\le &amp; \text{if } p^{nodal\_balance\_sense} = &quot;&lt;=&quot; \\
\end{cases} \\
&amp; 0 \\
&amp; \forall n \in node: p^{balance\_type}_{(n)} \ne balance\_type\_none \land \nexists ng \ni n : p^{balance\_type}_{(ng)} = balance\_type\_group \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#balance_type">balance_type</a> and <a href="../../concept_reference/Parameters/#nodal_balance_sense">nodal_balance_sense</a>.</p><h3 id="constraint_node_injection"><a class="docs-heading-anchor" href="#constraint_node_injection">Node injection</a><a id="constraint_node_injection-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_node_injection" title="Permalink"></a></h3><p>The node injection itself represents all local production and consumption, computed as the sum of all connected unit flows and the nodal demand. If a node corresponds to a storage node, the parameter <a href="../../concept_reference/Parameters/#has_state">has_state</a> should be set to <a href="../../concept_reference/Parameter Value Lists/#boolean_value_list">true</a> for this node. The node injection is created for each node in the network (unless the node is only used for parameter aggregation purposes, see <a href="../../concept_reference/the_basics/#Introduction-to-groups-of-objects">Introduction to groups of objects</a>).</p><p class="math-container">\[\begin{aligned}
&amp; v^{node\_injection}_{(n,s,t)} \\
&amp; = \\
&amp; \left(p^{state\_coeff}_{(n, s, t-1)} \cdot v^{node\_state}_{(n, s, t-1)} - p^{state\_coeff}_{(n, s, t)} \cdot v^{node\_state}_{(n, s, t)}\right)
/ \Delta t \\
&amp; - p^{frac\_state\_loss}_{(n,s,t)} \cdot v^{node\_state}_{(n, s, t)} \\
&amp; + \sum_{n&#39;} p^{diff\_coeff}_{(n&#39;,n,s,t)} \cdot v^{node\_state}_{(n&#39;, s, t)}
- \sum_{n&#39;} p^{diff\_coeff}_{(n,n&#39;,s,t)} \cdot v^{node\_state}_{(n, s, t)} \\
&amp; + \sum_{
        u
}
v^{unit\_flow}_{(u,n,to\_node,s,t)}
- \sum_{
        u
}
v^{unit\_flow}_{(u,n,from\_node,s,t)}\\
&amp; - \left(p^{demand}_{(n,s,t)} + \sum_{ng \ni n} p^{fractional\_demand}_{(n,s,t)} \cdot p^{demand}_{(ng,s,t)}\right) \\
&amp; + v^{node\_slack\_pos}_{(n,s,t)} - v^{node\_slack\_neg}_{(n,s,t)} \\
&amp; \forall n \in node: p^{has\_state}_{(n)}\\
&amp; \forall (s, t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#state_coeff">state_coeff</a>, <a href="../../concept_reference/Parameters/#frac_state_loss">frac_state_loss</a>, <a href="../../concept_reference/Parameters/#diff_coeff">diff_coeff</a>, <a href="../../concept_reference/Relationship Classes/#node__node">node__node</a>, <a href="../../concept_reference/Relationship Classes/#unit__from_node">unit__from_node</a>, <a href="../../concept_reference/Relationship Classes/#unit__to_node">unit__to_node</a>, <a href="../../concept_reference/Parameters/#demand">demand</a>, <a href="../../concept_reference/Parameters/#fractional_demand">fractional_demand</a>, <a href="../../concept_reference/Parameters/#has_state">has_state</a>.</p><h3 id="constraint_node_state_capacity"><a class="docs-heading-anchor" href="#constraint_node_state_capacity">Node state capacity</a><a id="constraint_node_state_capacity-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_node_state_capacity" title="Permalink"></a></h3><p>To limit the storage content, the <span>$v_{node\_state}$</span> variable needs be constrained by the following equation:</p><p class="math-container">\[v^{node\_state}_{(n, s, t)} \leq p^{node\_state\_cap}_{(n, s, t)} \quad \forall n \in node : p^{has\_state}_{(n)}, \, \forall (s,t)\]</p><p>The discharging and charging behavior of storage nodes can be described through unit(s), representing the link between the storage node and the supply node. Note that the dis-/charging efficiencies and capacities are properties of these units. See the <a href="@ref constraint_unit_flow_capacity">capacity constraint</a> and the <a href="@ref constraint_ratio_unit_flow">unit flow ratio constraints</a>.</p><p>See also <a href="../../concept_reference/Parameters/#node_state_cap">node_state_cap</a>, <a href="../../concept_reference/Parameters/#has_state">has_state</a>.</p><h3 id="constraint_cyclic_node_state"><a class="docs-heading-anchor" href="#constraint_cyclic_node_state">Cyclic condition on node state variable</a><a id="constraint_cyclic_node_state-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_cyclic_node_state" title="Permalink"></a></h3><p>To ensure that the node state at the end of the optimization is at least the same value as the initial value at the beginning of the optimization (or higher), the cyclic node state constraint can be used by setting the <a href="../../concept_reference/Parameters/#cyclic_condition">cyclic_condition</a> of a <a href="../../concept_reference/Relationship Classes/#node__temporal_block">node__temporal_block</a> to <code>true</code>. This triggers the following constraint:</p><p class="math-container">\[v^{node\_state}_{(n, s, start(tb))} \leq  v^{node\_state}_{(n, s, end(tb))}
\qquad \forall (n,tb) \in indices(p^{cyclic\_condition}): p^{cyclic\_condition}_{(n,tb)}\]</p><p>See also <a href="../../concept_reference/Parameters/#cyclic_condition">cyclic_condition</a>.</p><h2 id="Unit-operation"><a class="docs-heading-anchor" href="#Unit-operation">Unit operation</a><a id="Unit-operation-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-operation" title="Permalink"></a></h2><p>In the following, the operational constraints on the variables associated with units will be elaborated on. The static constraints, in contrast to the dynamic constraints, are addressing constraints without sequential time-coupling. It should however be noted that static constraints can still perform temporal aggregation.</p><h3 id="static-constraints-unit"><a class="docs-heading-anchor" href="#static-constraints-unit">Static constraints</a><a id="static-constraints-unit-1"></a><a class="docs-heading-anchor-permalink" href="#static-constraints-unit" title="Permalink"></a></h3><p>The fundamental static constraints for units within SpineOpt relate to the relationships between commodity flows from and to units and to limits on the unit flow capacity.</p><h4 id="constraint_ratio_unit_flow"><a class="docs-heading-anchor" href="#constraint_ratio_unit_flow">Conversion constraint / limiting flow shares inprocess / relationship in process</a><a id="constraint_ratio_unit_flow-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_ratio_unit_flow" title="Permalink"></a></h4><p>A <a href="../../concept_reference/Object Classes/#unit">unit</a> can have different commodity flows associated with it. The most simple relationship between these flows is a linear relationship between input and/or output nodes/node groups. SpineOpt holds constraints for each combination of flows and also for the type of relationship, i.e. whether it is a maximum, minimum or fixed ratio between commodity flows. Note that node groups can be used in order to aggregate flows, i.e. to give a ratio between a combination of units flows.</p><h5 id="ratio_unit_flow"><a class="docs-heading-anchor" href="#ratio_unit_flow">Ratios between flows of a unit</a><a id="ratio_unit_flow-1"></a><a class="docs-heading-anchor-permalink" href="#ratio_unit_flow" title="Permalink"></a></h5><p>By specifying the parameters <a href="../../concept_reference/Parameters/#fix_ratio_out_in_unit_flow">fix_ratio_out_in_unit_flow</a>, <a href="../../concept_reference/Parameters/#fix_ratio_in_out_unit_flow">fix_ratio_in_out_unit_flow</a>, <a href="../../concept_reference/Parameters/#fix_ratio_in_in_unit_flow">fix_ratio_in_in_unit_flow</a>, and/or <a href="../../concept_reference/Parameters/#fix_ratio_out_out_unit_flow">fix_ratio_out_out_unit_flow</a>, a <strong>fix</strong> ratio can be set between, respectively, <strong>out</strong>going and <strong>in</strong>coming flows from and to a unit, <strong>in</strong>coming and <strong>out</strong>going flows to and from a unit, two <strong>in</strong>coming flows to a unit, and/or two <strong>out</strong>going flows from a unit.</p><p>Similary, a <strong>minimum</strong> ratio between flows can be set by specifying <a href="../../concept_reference/Parameters/#min_ratio_out_in_unit_flow">min_ratio_out_in_unit_flow</a>, <a href="../../concept_reference/Parameters/#min_ratio_in_out_unit_flow">min_ratio_in_out_unit_flow</a>, <a href="../../concept_reference/Parameters/#min_ratio_in_in_unit_flow">min_ratio_in_in_unit_flow</a>, and/or <a href="../../concept_reference/Parameters/#min_ratio_out_out_unit_flow">min_ratio_out_out_unit_flow</a>.</p><p>Finally, a <strong>maximum</strong> ratio can be set by specifying <a href="../../concept_reference/Parameters/#max_ratio_out_in_unit_flow">max_ratio_out_in_unit_flow</a>, <a href="../../concept_reference/Parameters/#max_ratio_in_out_unit_flow">max_ratio_in_out_unit_flow</a>, <a href="../../concept_reference/Parameters/#max_ratio_in_in_unit_flow">max_ratio_in_in_unit_flow</a>, and/or <a href="../../concept_reference/Parameters/#max_ratio_out_out_unit_flow">max_ratio_out_out_unit_flow</a>.</p><p>For example, whenever there is only a single input node and a single output node, <a href="../../concept_reference/Parameters/#fix_ratio_out_in_unit_flow">fix_ratio_out_in_unit_flow</a> relates to the notion of efficiency. Also, <a href="../../concept_reference/Parameters/#fix_ratio_in_out_unit_flow">fix_ratio_in_out_unit_flow</a> can for instance be used to relate emissions to input primary fuel flows.</p><p>The constraint below is written for <a href="../../concept_reference/Parameters/#fix_ratio_out_in_unit_flow">fix_ratio_out_in_unit_flow</a>, but equivalent formulations exist for the other 11 cases described above.</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{n \in ng_{out}} v^{unit\_flow}_{(u,n,from\_node,s,t)} \\
&amp; = \\
&amp; p^{fix\_ratio\_out\_in\_unit\_flow}_{(u, ng_{out}, ng_{in},s,t)}
\cdot \sum_{n \in ng_{in}} v^{unit\_flow}_{(u,n,to\_node,s,t)} \\
&amp; + p^{fix\_units\_on\_coefficient\_out\_in}_{(u,ng_{out},ng_{in},s,t)} \cdot v^{units\_on}_{(u,s,t)}  \\
&amp; \forall (u, ng_{out}, ng_{in}) \in indices(p^{fix\_ratio\_out\_in\_unit\_flow}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If any of the above mentioned ratio parameters is specified for a node group, then the ratio is enforced over the <em>sum</em> of flows from or to that group. In this case, there remains a degree of freedom regarding the composition of flows within the group.</p></div></div><p>See also <a href="../../concept_reference/Parameters/#fix_ratio_out_in_unit_flow">fix_ratio_out_in_unit_flow</a>, <a href="../../concept_reference/Parameters/#fix_units_on_coefficient_out_in">fix_units_on_coefficient_out_in</a>.</p><h5 id="constraint_unit_flow_capacity"><a class="docs-heading-anchor" href="#constraint_unit_flow_capacity">Bounds on the unit capacity</a><a id="constraint_unit_flow_capacity-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_unit_flow_capacity" title="Permalink"></a></h5><p>In a multi-commodity setting, there can be different commodities entering/leaving a certain technology/unit. These can be energy-related commodities (e.g., electricity, natural gas, etc.), emissions, or other commodities (e.g., water, steel). The <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a> must be specified for at least one <a href="../../concept_reference/Relationship Classes/#unit__to_node">unit__to_node</a> or <a href="../../concept_reference/Relationship Classes/#unit__from_node">unit__from_node</a> relationship, in order to trigger a constraint on the maximum commodity flows to this location in each time step. When desirable, the capacity can be specified for a group of nodes (e.g. combined capacity for multiple products).</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{
        n \in ng
}
    v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[ \neg p^{is\_reserve\_node}_{(n)} \right]\\
&amp; + \sum_{
        n \in ng
}
    v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[
        p^{is\_reserve\_node}_{(n)} \land p^{upward\_reserve}_{(n)} \land \neg p^{is\_non\_spinning}_{(n)} 
    \right]\\
&amp; \le \\
&amp; p^{unit\_capacity}_{(u,ng,d,s,t)} \cdot p^{unit\_availability\_factor}_{(u,s,t)} \cdot p^{unit\_conv\_cap\_to\_flow}_{(u,ng,d,s,t)} \\
&amp; \cdot ( \\
&amp; \qquad v^{units\_on}_{(u,s,t)} \\
&amp; \qquad - \left(1 - p^{shut\_down\_limit}_{(u,ng,d,s,t)}\right)
\cdot \left( v^{units\_shut\_down}_{(u,s,t+1)}
+ \sum_{
    n \in ng
} v^{nonspin\_units\_shut\_down}_{(u,n,s,t)} \right) \\
&amp; \qquad - \left(1 - p^{start\_up\_limit}_{(u,ng,d,s,t)}\right) \cdot v^{units\_started\_up}_{(u,s,t)} \\
&amp; ) \\
&amp; \forall (u,ng,d) \in indices(p^{unit\_capacity}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>where</p><p class="math-container">\[[p] \vcentcolon = \begin{cases}
1 &amp; \text{if } p \text{ is true;}\\
0 &amp; \text{otherwise.}
\end{cases}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The conversion factor <a href="../../concept_reference/Parameters/#unit_conv_cap_to_flow">unit_conv_cap_to_flow</a> has a default value of <code>1</code>, but can be adjusted in case the unit of measurement for the capacity is different to the unit flows unit of measurement.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above formulation is valid for time-slices whose duration is greater than the minimum up time of the unit. This ensures that the unit is not online for exactly one time-slice, which might result in an infeasibility if this formulation was used. Instead, for time-slices whose duration is lower or equal than the minimum up time of the unit there is a similar formulation, but the details are omitted for brevity.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above formulation is valid for flows going from a unit to a node (i.e., output flows). For flows going from a node to a unit (i.e., input flows) the direction of the reserves is switched (downwards becomes upwards, non-spinning units shut-down becomes non-spinning units started-up). The details are omitted for brevity.</p></div></div><p>See also <a href="../../concept_reference/Parameters/#is_reserve_node">is_reserve_node</a>, <a href="../../concept_reference/Parameters/#upward_reserve">upward_reserve</a>, <a href="../../concept_reference/Parameters/#is_non_spinning">is_non_spinning</a>, <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>, <a href="../../concept_reference/Parameters/#unit_availability_factor">unit_availability_factor</a>, <a href="../../concept_reference/Parameters/#unit_conv_cap_to_flow">unit_conv_cap_to_flow</a>, <a href="../../concept_reference/Parameters/#start_up_limit">start_up_limit</a>, <a href="../../concept_reference/Parameters/#shut_down_limit">shut_down_limit</a>.</p><h5 id="constraint_minimum_operating_point"><a class="docs-heading-anchor" href="#constraint_minimum_operating_point">Constraint on minimum operating point</a><a id="constraint_minimum_operating_point-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_minimum_operating_point" title="Permalink"></a></h5><p>The minimum operating point of a unit is based on the <a href="../variables/#unit_flow">unit_flow</a>s of input or output nodes/node groups.</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[\neg p^{is\_reserve\_node}_{(n)}\right]
- \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[p^{is\_reserve\_node}_{(n)} \land p^{downward\_reserve}_{(n)}\right] \\
&amp; \ge p^{minimum\_operating\_point}_{(u,ng,d,s,t)} \cdot p^{unit\_capacity}_{(u,ng,d,s,t)} \cdot p^{unit\_conv\_cap\_to\_flow}_{(u,ng,d,s,t)} \\
&amp; \cdot \left( v^{units\_on}_{(u,s,t)}
- \sum_{
    n \in ng
} v^{nonspin\_units\_shut\_down}_{(u,n,s,t)} \right) \\
&amp; \forall (u,ng,d) \in indices(p^{minimum\_operating\_point}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>where</p><p class="math-container">\[[p] \vcentcolon = \begin{cases}
1 &amp; \text{if } p \text{ is true;}\\
0 &amp; \text{otherwise.}
\end{cases}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above formulation is valid for flows going from a unit to a node (i.e., output flows). For flows going from a node to a unit (i.e., input flows) the direction of the reserves is switched (downwards becomes upwards, non-spinning units shut-down becomes non-spinning units started-up). The details are omitted for brevity.</p></div></div><p>See also <a href="../../concept_reference/Parameters/#is_reserve_node">is_reserve_node</a>, <a href="../../concept_reference/Parameters/#downward_reserve">downward_reserve</a>, <a href="../../concept_reference/Parameters/#is_non_spinning">is_non_spinning</a>, <a href="../../concept_reference/Parameters/#minimum_operating_point">minimum_operating_point</a>, <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>, <a href="../../concept_reference/Parameters/#unit_conv_cap_to_flow">unit_conv_cap_to_flow</a></p><h3 id="Dynamic-constraints"><a class="docs-heading-anchor" href="#Dynamic-constraints">Dynamic constraints</a><a id="Dynamic-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-constraints" title="Permalink"></a></h3><h4 id="Commitment-constraints"><a class="docs-heading-anchor" href="#Commitment-constraints">Commitment constraints</a><a id="Commitment-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Commitment-constraints" title="Permalink"></a></h4><p>For modeling certain technologies/units, it is important to not only have <a href="../variables/#unit_flow">unit_flow</a> variables of different commodities, but also model the online (&quot;commitment&quot;) status of the unit/technology at every time step. Therefore, an additional variable <a href="../variables/#units_on">units_on</a> is introduced. This variable represents the number of online units of that technology (for a normal unit commitment model, this variable might be a binary, for investment planning purposes, this might also be an integer or even a continuous variable). To define the type of a commitment variable, see <a href="../../concept_reference/Parameters/#online_variable_type">online_variable_type</a>. Commitment variables will be introduced by the following constraints (with corresponding parameters):</p><ul><li>constraint on <code>units_on</code></li><li>constraint on <code>units_available</code></li><li>constraint on the unit state transition</li><li>constraint on minimum down time</li><li>constraint on minimum up time</li><li>constraint on ramp rates</li><li>constraint on reserve provision</li></ul><h5 id="constraint_units_available"><a class="docs-heading-anchor" href="#constraint_units_available">Bound on available units</a><a id="constraint_units_available-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_units_available" title="Permalink"></a></h5><p>The aggregated available units are constrained by the parameter <a href="../../concept_reference/Parameters/#number_of_units">number_of_units</a> , the variable number of invested units <a href="../variables/#units_invested_available">units_invested_available</a> less the number of units on outage <a href="@ref">units_out_of_service</a>:</p><p class="math-container">\[\begin{aligned}
&amp; v^{units\_available}_{(u,s,t)} \leq p^{number\_of\_units}_{(u,s,t)} + v^{units\_invested\_available}_{(u,s,t)} + v^{units\_out\_of\_service}_{(u,s,t)}\\
&amp; \forall u \in unit \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#number_of_units">number_of_units</a>.</p><h5 id="constraint_unit_state_transition"><a class="docs-heading-anchor" href="#constraint_unit_state_transition">Unit state transition</a><a id="constraint_unit_state_transition-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_unit_state_transition" title="Permalink"></a></h5><p>The units on status is constrained by shutting down and starting up actions. This transition is defined as follows:</p><p class="math-container">\[\begin{aligned}
&amp; v^{units\_on}_{(u,s,t)} - v^{units\_started\_up}_{(u,s,t)} + v^{units\_shut\_down}_{(u,s,t)} = v^{units\_on}_{(u,s,t-1)} \\
&amp; \forall u \in unit \\
&amp; \forall (s,t)
\end{aligned}\]</p><h5 id="constraint_min_down_time"><a class="docs-heading-anchor" href="#constraint_min_down_time">Minimum down time</a><a id="constraint_min_down_time-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_min_down_time" title="Permalink"></a></h5><p>Similarly to the <a href="@ref constraint_min_up_time">minimum up time constraint</a>, a minimum time that a unit needs to remain offline after a shut down can be imposed by defining the <a href="../../concept_reference/Parameters/#min_down_time">min_down_time</a> parameter. This will trigger the generation of the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; p^{number\_of\_units}_{(u,s,t)} + v^{units\_invested\_available}_{(u,s,t)} - v^{units\_on}_{(u,s,t)} \\
&amp; - \sum_{n} v^{nonspin\_units\_started\_up}_{(u,n,s,t)} \\
&amp; \geq
\sum_{t&#39;=t-p^{min\_down\_time}_{(u,s,t)} + 1}^{t}
v^{units\_shut\_down}_{(u,s,t&#39;)} \\
&amp; \forall u \in indices(p^{min\_down\_time})\\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#number_of_units">number_of_units</a>, <a href="../../concept_reference/Parameters/#min_down_time">min_down_time</a>.</p><h5 id="constraint_min_up_time"><a class="docs-heading-anchor" href="#constraint_min_up_time">Minimum up time</a><a id="constraint_min_up_time-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_min_up_time" title="Permalink"></a></h5><p>Similarly to the <a href="@ref constraint_min_down_time">minimum down time constraint</a>, a minimum time that a unit needs to remain online after a start up can be imposed by defining the <a href="../../concept_reference/Parameters/#min_up_time">min_up_time</a> parameter. This will trigger the generation of the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; v^{units\_on}_{(u,s,t)} - \sum_{n} v^{nonspin\_units\_shut\_down}_{(u,n,s,t)} \\
&amp; \geq
\sum_{t&#39;=t-p^{min\_up\_time}_{(u,s,t)} +1 }^{t}
v^{units\_started\_up}_{(u,s,t&#39;)} \\
&amp; \forall u \in indices(p^{min\_up\_time})\\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#min_up_time">min_up_time</a></p><h4 id="Ramping-constraints"><a class="docs-heading-anchor" href="#Ramping-constraints">Ramping constraints</a><a id="Ramping-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Ramping-constraints" title="Permalink"></a></h4><p>To include ramping and reserve constraints, it is a pre requisite that <a href="@ref constraint_minimum_operating_point">minimum operating points</a> and <a href="@ref constraint_unit_flow_capacity">capacity constraints</a> are enforced as described.</p><p>For dispatchable units, additional ramping constraints can be introduced. For setting up ramping characteristics of units see <a href="../../advanced_concepts/ramping/#Ramping">Ramping</a>.</p><h5 id="constraint_ramp_up"><a class="docs-heading-anchor" href="#constraint_ramp_up">Ramp up limit</a><a id="constraint_ramp_up-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_ramp_up" title="Permalink"></a></h5><p>Limit the increase of <a href="../variables/#unit_flow">unit_flow</a> over a time period of one <a href="../../concept_reference/Parameters/#duration_unit">duration_unit</a> according to the <a href="../../concept_reference/Parameters/#start_up_limit">start_up_limit</a> and <a href="../../concept_reference/Parameters/#ramp_up_limit">ramp_up_limit</a> parameter values.</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[ \neg p^{is\_reserve\_node}_{(n)} \right] \\
&amp; - \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t-1)} \cdot \left[ \neg p^{is\_reserve\_node}_{(n)} \right] \\
&amp; + \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[ p^{is\_reserve\_node}_{(n)} \land p^{upward\_reserve}_{(n)} \right] \\
&amp; \le ( \\
&amp; \qquad \left(p^{start\_up\_limit}_{(u,ng,d,s,t)} - p^{minimum\_operating\_point}_{(u,ng,d,s,t)}
- p^{ramp\_up\_limit}_{(u,ng,d,s,t)}\right) \cdot v^{units\_started\_up}_{(u,s,t)} \\
&amp; \qquad + \left(p^{minimum\_operating\_point}_{(u,ng,d,s,t)} + p^{ramp\_up\_limit}_{(u,ng,d,s,t)}\right)
\cdot v^{units\_on}_{(u,s,t)} \\
&amp; \qquad - p^{minimum\_operating\_point}_{(u,ng,d,s,t)} \cdot v^{units\_on}_{(u,s,t-1)} \\
&amp; ) \cdot p^{unit\_capacity}_{(u,ng,d,s,t)} \cdot p^{unit\_conv\_cap\_to\_flow}_{(u,ng,d,s,t)} \cdot \Delta t \\
&amp; \forall (u,ng,d) \in indices(p^{ramp\_up\_limit}) \cup indices(p^{start\_up\_limit}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>where</p><p class="math-container">\[[p] \vcentcolon = \begin{cases}
1 &amp; \text{if } p \text{ is true;}\\
0 &amp; \text{otherwise.}
\end{cases}\]</p><p>See also <a href="../../concept_reference/Parameters/#is_reserve_node">is_reserve_node</a>, <a href="../../concept_reference/Parameters/#upward_reserve">upward_reserve</a>, <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>, <a href="../../concept_reference/Parameters/#unit_conv_cap_to_flow">unit_conv_cap_to_flow</a>, <a href="../../concept_reference/Parameters/#ramp_up_limit">ramp_up_limit</a>, <a href="../../concept_reference/Parameters/#start_up_limit">start_up_limit</a>, <a href="../../concept_reference/Parameters/#minimum_operating_point">minimum_operating_point</a>.</p><h5 id="constraint_ramp_down"><a class="docs-heading-anchor" href="#constraint_ramp_down">Ramp down limit</a><a id="constraint_ramp_down-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_ramp_down" title="Permalink"></a></h5><p>Limit the decrease of <a href="../variables/#unit_flow">unit_flow</a> over a time period of one <a href="../../concept_reference/Parameters/#duration_unit">duration_unit</a> according to the <a href="../../concept_reference/Parameters/#shut_down_limit">shut_down_limit</a> and <a href="../../concept_reference/Parameters/#ramp_down_limit">ramp_down_limit</a> parameter values.</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t-1)} \cdot \left[ \neg p^{is\_reserve\_node}_{(n)} \right] \\
&amp; - \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[ \neg p^{is\_reserve\_node}_{(n)} \right] \\
&amp; + \sum_{
        n \in ng
}
v^{unit\_flow}_{(u,n,d,s,t)} \cdot \left[ p^{is\_reserve\_node}_{(n)} \land p^{downward\_reserve}_{(n)} \right] \\
&amp; \le ( \\
&amp; \qquad \left(p^{shut\_down\_limit}_{(u,ng,d,s,t)} - p^{minimum\_operating\_point}_{(u,ng,d,s,t)} - p^{ramp\_down\_limit}_{(u,ng,d,s,t)}\right) \cdot v^{units\_shut\_down}_{(u,s,t)} \\
&amp; \qquad + \left(p^{minimum\_operating\_point}_{(u,ng,d,s,t)} + p^{ramp\_down\_limit}_{(u,ng,d,s,t)}\right) \cdot v^{units\_on}_{(u,s,t-1)} \\
&amp; \qquad - p^{minimum\_operating\_point}_{(u,ng,d,s,t)} \cdot v^{units\_on}_{(u,s,t)} \\
&amp; ) \cdot p^{unit\_capacity}_{(u,ng,d,s,t)} \cdot p^{unit\_conv\_cap\_to\_flow}_{(u,ng,d,s,t)} \cdot \Delta t \\
&amp; \forall (u,ng,d) \in indices(p^{ramp\_down\_limit}) \cup indices(p^{shut\_down\_limit}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>where</p><p class="math-container">\[[p] \vcentcolon = \begin{cases}
1 &amp; \text{if } p \text{ is true;}\\
0 &amp; \text{otherwise.}
\end{cases}\]</p><p>See also <a href="../../concept_reference/Parameters/#is_reserve_node">is_reserve_node</a>, <a href="../../concept_reference/Parameters/#downward_reserve">downward_reserve</a>, <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>, <a href="../../concept_reference/Parameters/#unit_conv_cap_to_flow">unit_conv_cap_to_flow</a>, <a href="../../concept_reference/Parameters/#ramp_down_limit">ramp_down_limit</a>, <a href="../../concept_reference/Parameters/#shut_down_limit">shut_down_limit</a>, <a href="../../concept_reference/Parameters/#minimum_operating_point">minimum_operating_point</a>.</p><h4 id="Reserve-constraints"><a class="docs-heading-anchor" href="#Reserve-constraints">Reserve constraints</a><a id="Reserve-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Reserve-constraints" title="Permalink"></a></h4><h5 id="constraint_res_minimum_node_state"><a class="docs-heading-anchor" href="#constraint_res_minimum_node_state">Constraint on minimum node state for reserve provision</a><a id="constraint_res_minimum_node_state-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_res_minimum_node_state" title="Permalink"></a></h5><p>(Comment 2023-11-20: Currently under development)</p><h3 id="Operating-segments"><a class="docs-heading-anchor" href="#Operating-segments">Operating segments</a><a id="Operating-segments-1"></a><a class="docs-heading-anchor-permalink" href="#Operating-segments" title="Permalink"></a></h3><h4 id="constraint_operating_point_bounds"><a class="docs-heading-anchor" href="#constraint_operating_point_bounds">Operating segments of units</a><a id="constraint_operating_point_bounds-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_operating_point_bounds" title="Permalink"></a></h4><p>Limit the maximum number of each activated segment <code>unit_flow_op_active</code> cannot be higher than the number of online units. This constraint is activated only when parameter <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a> is set <code>true</code>.</p><p class="math-container">\[\begin{aligned}
&amp; v^{unit\_flow\_op\_active}_{(u,n,d,op,s,t)} \leq v^{units\_on}_{(u,s,t)} \\
&amp; \forall (u,n,d) \in indices(p^{operating\_points}): p^{ordered\_unit\_flow\_op}_{(u,n,d)} \\
&amp; \forall op \in \{ 1, \ldots, \left\|p^{operating\_points}_{(u,n,d)}\right\| \} \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#operating_points">operating_points</a>, <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a>.</p><h4 id="constraint_operating_point_rank"><a class="docs-heading-anchor" href="#constraint_operating_point_rank">Rank operating segments as per the index of operating points</a><a id="constraint_operating_point_rank-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_operating_point_rank" title="Permalink"></a></h4><p>Rank operating segments by enforcing that the variable <code>unit_flow_op_active</code> of operating point <code>i</code> can only be active  if previous operating point <code>i-1</code> is also active. The first segment does not need this constraint.</p><p class="math-container">\[\begin{aligned}
&amp; v^{unit\_flow\_op\_active}_{(u,n,d,op,s,t)} \leq v^{unit\_flow\_op\_active}_{(u,n,d,op-1,s,t)} \\
&amp; \forall (u,n,d) \in indices(p^{operating\_points}): p^{ordered\_unit\_flow\_op}_{(u,n,d)} \\
&amp; \forall op \in \{ 2, \ldots, \left\|p^{operating\_points}_{(u,n,d)}\right\| \} \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#operating_points">operating_points</a>, <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a>.</p><h4 id="unit_flow_op_bounds"><a class="docs-heading-anchor" href="#unit_flow_op_bounds">Operating segments of units</a><a id="unit_flow_op_bounds-1"></a><a class="docs-heading-anchor-permalink" href="#unit_flow_op_bounds" title="Permalink"></a></h4><p>If the segments of a <code>unit_flow</code>, i.e. <code>unit_flow_op</code> is not ordered according to the rank of the <code>unit_flow</code>&#39;s <a href="../../concept_reference/Parameters/#operating_points">operating_points</a> (parameter <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a> is <code>false</code>), the operating segment variable <code>unit_flow_op</code> is only bounded by the difference between successive <a href="../../concept_reference/Parameters/#operating_points">operating_points</a> adjusted for available capacity. If the order is enforced on the segments (parameter <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a> is <code>true</code>), <code>unit_flow_op</code> can only be active if the segment is active (variable <a href="../variables/#unit_flow_op_active">unit_flow_op_active</a> is <code>true</code>) besides being bounded by the segment capacity.</p><p class="math-container">\[\begin{aligned}
&amp; v^{unit\_flow\_op}_{(u, n, d, op, s, t)} \\
&amp; \leq p^{unit\_capacity}_{(u, n, d, s, t)} \cdot p^{unit\_conv\_cap\_to\_flow}_{(u, n, d, s, t)} \cdot p^{unit\_availability\_factor}_{(u, s, t)} \\
&amp; \cdot \left( p^{operating\_points}_{(u, n, d, op, s, t)}
- \begin{cases}       
   p^{operating\_points}_{(u, n, op-1, s, t)} &amp; \text{if } op &gt; 1\\
   0 &amp; \text{otherwise}\\
\end{cases} \right) \\
&amp; \cdot \begin{cases}
    v^{unit\_flow\_op\_active}_{(u,n,d,op,s,t)} &amp; \text{if } p^{ordered\_unit\_flow\_op}_{(u,s,t)} \\
    v^{units\_on}_{(u,s,t)} &amp; \text{otherwise}\\
\end{cases} \\
&amp; \forall (u,n,d) \in indices(p^{unit\_capacity}) \cup indices(p^{operating\_points}) \\
&amp; \forall op \in \{ 1, \ldots, \left\|p^{operating\_points}_{(u,n,d)}\right\| \} \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>, <a href="../../concept_reference/Parameters/#unit_conv_cap_to_flow">unit_conv_cap_to_flow</a>, <a href="../../concept_reference/Parameters/#unit_availability_factor">unit_availability_factor</a>, <a href="../../concept_reference/Parameters/#operating_points">operating_points</a>, <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a>.</p><h4 id="unit_flow_op_rank"><a class="docs-heading-anchor" href="#unit_flow_op_rank">Bounding operating segments to use up its own capacity for activating the next segment</a><a id="unit_flow_op_rank-1"></a><a class="docs-heading-anchor-permalink" href="#unit_flow_op_rank" title="Permalink"></a></h4><p>Enforce the operating point flow variable <code>unit_flow_op</code> at operating point <code>i</code> to use its full capacity if the subsequent operating point <code>i+1</code> is active if parameter <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a> is set <code>true</code>. The last segment does not need this constraint.</p><p class="math-container">\[\begin{aligned}
&amp; v^{unit\_flow\_op}{(u, n, d, op, s, t)} \\
&amp; \geq p^{unit\_capacity}_{(u, n, d, s, t)} \cdot p^{unit\_conv\_cap\_to\_flow}_{(u, n, d, s, t)} \\
&amp; \cdot \left(p^{operating\_points}_{(u, n, op, s, t)} - \begin{cases}       
   p^{operating\_points}_{(u, n, op-1, s, t)} &amp; \text{if } op &gt; 1 \\
   0 &amp; \text{otherwise} \\
\end{cases} \right) \\
&amp; \cdot v^{unit\_flow\_op\_active}_{(u, n, d, op+1, s, t)} \\
&amp; \forall (u,n,d) \in indices(p^{unit\_capacity}) \cup indices(p^{operating\_points}): p^{ordered\_unit\_flow\_op}_{(u,n,d)} \\
&amp; \forall op \in \{ 1, \ldots, \left\|p^{operating\_points}_{(u,n,d)}\right\| - 1\} \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#unit_capacity">unit_capacity</a>, <a href="../../concept_reference/Parameters/#unit_conv_cap_to_flow">unit_conv_cap_to_flow</a>, <a href="../../concept_reference/Parameters/#operating_points">operating_points</a>, <a href="../../concept_reference/Parameters/#ordered_unit_flow_op">ordered_unit_flow_op</a>.</p><h4 id="unit_flow_op_sum"><a class="docs-heading-anchor" href="#unit_flow_op_sum">Bounding unit flows by summing over operating segments</a><a id="unit_flow_op_sum-1"></a><a class="docs-heading-anchor-permalink" href="#unit_flow_op_sum" title="Permalink"></a></h4><p><a href="../variables/#unit_flow">unit_flow</a> is constrained to be the sum of all operating segment variables, <a href="../variables/#unit_flow_op">unit_flow_op</a></p><p class="math-container">\[\begin{aligned}
&amp; v^{unit\_flow}_{(u, n, d, s, t)} = \sum_{op=1}^{\left\|p^{operating\_points}_{(u,n,d)}\right\|} v^{unit\_flow\_op}_{(u, n, d, op, s, t)} \\
&amp; \forall (u,n,d) \in indices(p^{operating\_points}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#operating_points">operating_points</a>.</p><h4 id="constraint_unit_pw_heat_rate"><a class="docs-heading-anchor" href="#constraint_unit_pw_heat_rate">Unit piecewise incremental heat rate</a><a id="constraint_unit_pw_heat_rate-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_unit_pw_heat_rate" title="Permalink"></a></h4><p>Implements a standard piecewise linear heat-rate function where <a href="../variables/#unit_flow">unit_flow</a> from a (input fuel consumption) node is equal to the sum over operating point segments of <a href="../variables/#unit_flow_op">unit_flow_op</a> to a (output electricity node) node times the corresponding <a href="@ref">incremental_heat_rate</a>.</p><p class="math-container">\[\begin{aligned}
&amp; v^{unit\_flow}_{(u, n_{in}, d, s, t)} \\
&amp; = \sum_{op=1}^{\left\|p^{operating\_points}_{(u,n,d)}\right\|} p^{unit\_incremental\_heat\_rate}_{(u, n_{in}, n_{out}, op, s, t)}
\cdot v^{unit\_flow\_op}_{(u, n_{out}, d, op, s, t)} \\
&amp; + p^{unit\_idle\_heat\_rate}_{(u, n_{in}, n_{out}, s, t)} \cdot v^{units\_on}_{(u, s, t)} \\
&amp; + p^{unit\_start\_flow}_{(u, n_{in}, n_{out}, s, t)} \cdot v^{units\_started\_up}_{(u, s, t)} \\
&amp; \forall (u,n_{in},n_{out}) \in indices(p^{unit\_incremental\_heat\_rate}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#unit_incremental_heat_rate">unit_incremental_heat_rate</a>, <a href="../../concept_reference/Parameters/#unit_idle_heat_rate">unit_idle_heat_rate</a>, <a href="../../concept_reference/Parameters/#unit_start_flow">unit_start_flow</a>.</p><h3 id="Bounds-on-commodity-flows"><a class="docs-heading-anchor" href="#Bounds-on-commodity-flows">Bounds on commodity flows</a><a id="Bounds-on-commodity-flows-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-commodity-flows" title="Permalink"></a></h3><h4 id="constraint_total_cumulated_unit_flow"><a class="docs-heading-anchor" href="#constraint_total_cumulated_unit_flow">Bound on cumulated unit flows</a><a id="constraint_total_cumulated_unit_flow-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_total_cumulated_unit_flow" title="Permalink"></a></h4><p>To impose a limit on the cumulative amount of certain commodity flows, a cumulative bound can be set by defining one of the following parameters:</p><ul><li><a href="../../concept_reference/Parameters/#max_total_cumulated_unit_flow_from_node">max_total_cumulated_unit_flow_from_node</a></li><li><a href="../../concept_reference/Parameters/#min_total_cumulated_unit_flow_from_node">min_total_cumulated_unit_flow_from_node</a></li><li><a href="../../concept_reference/Parameters/#max_total_cumulated_unit_flow_to_node">max_total_cumulated_unit_flow_to_node</a></li><li><a href="../../concept_reference/Parameters/#min_total_cumulated_unit_flow_to_node">min_total_cumulated_unit_flow_to_node</a></li></ul><p>A maximum cumulated flow restriction can for example be used to limit emissions or consumption of a certain commodity.</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{u \in ug, n \in ng} v^{unit\_flow}_{(u,n,d,s,t)} \leq p^{max\_total\_cumulated\_unit\_flow\_from\_node}_{(ug,ng,d)} \\
&amp; \forall (ug,ng,d) \in indices(p^{max\_total\_cumulated\_unit\_flow\_from\_node}), \, \forall s \\
&amp; \sum_{u \in ug, n \in ng} v^{unit\_flow}_{(u,n,d,s,t)} \geq p^{min\_total\_cumulated\_unit\_flow\_from\_node}_{(ug,ng,d)} \\
&amp; \forall (ug,ng,d) \in indices(p^{min\_total\_cumulated\_unit\_flow\_from\_node}), \, \forall s \\
&amp; \sum_{u \in ug, n \in ng} v^{unit\_flow}_{(u,n,d,s,t)} \leq p^{max\_total\_cumulated\_unit\_flow\_to\_node}_{(ug,ng,d)} \\
&amp; \forall (ug,ng,d) \in indices(p^{max\_total\_cumulated\_unit\_flow\_to\_node}), \, \forall s \\
&amp; \sum_{u \in ug, n \in ng} v^{unit\_flow}_{(u,n,d,s,t)} \geq p^{min\_total\_cumulated\_unit\_flow\_to\_node}_{(ug,ng,d)} \\
&amp; \forall (ug,ng,d) \in indices(p^{min\_total\_cumulated\_unit\_flow\_to\_node}), \, \forall s \\
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#max_total_cumulated_unit_flow_from_node">max_total_cumulated_unit_flow_from_node</a>, <a href="../../concept_reference/Parameters/#min_total_cumulated_unit_flow_from_node">min_total_cumulated_unit_flow_from_node</a>, <a href="../../concept_reference/Parameters/#max_total_cumulated_unit_flow_to_node">max_total_cumulated_unit_flow_to_node</a>, <a href="../../concept_reference/Parameters/#min_total_cumulated_unit_flow_to_node">min_total_cumulated_unit_flow_to_node</a>.</p><h2 id="Network-constraints"><a class="docs-heading-anchor" href="#Network-constraints">Network constraints</a><a id="Network-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Network-constraints" title="Permalink"></a></h2><h3 id="static-constraints-connection"><a class="docs-heading-anchor" href="#static-constraints-connection">Static constraints</a><a id="static-constraints-connection-1"></a><a class="docs-heading-anchor-permalink" href="#static-constraints-connection" title="Permalink"></a></h3><h4 id="constraint_connection_flow_capacity"><a class="docs-heading-anchor" href="#constraint_connection_flow_capacity">Capacity constraint on connections</a><a id="constraint_connection_flow_capacity-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_flow_capacity" title="Permalink"></a></h4><p>In a multi-commodity setting, there can be different commodities entering/leaving a certain connection. These can be energy-related commodities (e.g., electricity, natural gas, etc.), emissions, or other commodities (e.g., water, steel). The <a href="../../concept_reference/Parameters/#connection_capacity">connection_capacity</a> should be specified for at least one <a href="../../concept_reference/Relationship Classes/#connection__to_node">connection__to_node</a> or <a href="../../concept_reference/Relationship Classes/#connection__from_node">connection__from_node</a> relationship, in order to trigger a constraint on the maximum commodity flows to this location in each time step. When desirable, the capacity can be specified for a group of nodes (e.g. combined capacity for multiple products).</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{n \in ng} v^{connection\_flow}_{(conn,n,d,s,t)} \\
&amp; &lt;= \\
&amp; p^{connection\_capacity}_{(conn,ng,d,s,t)} \cdot p^{connection\_availability\_factor}_{(conn,s,t)} \cdot p^{connection\_conv\_cap\_to\_flow}_{(conn,ng,d,s,t)} \\
&amp; \cdot \left( p^{number\_of\_connections}_{(conn,s,t)} + v^{connections\_invested\_available}_{(conn,s,t)} \right)\\
&amp; \forall (conn,ng,d) \in indices(p^{connection\_capacity}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#connection_capacity">connection_capacity</a>, <a href="../../concept_reference/Parameters/#connection_availability_factor">connection_availability_factor</a>, <a href="../../concept_reference/Parameters/#connection_conv_cap_to_flow">connection_conv_cap_to_flow</a>, <a href="../../concept_reference/Parameters/#number_of_connections">number_of_connections</a>, <a href="../../concept_reference/Parameters/#candidate_connections">candidate_connections</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For situations where the same <a href="../../concept_reference/Object Classes/#connection">connection</a> handles flows to multiple <a href="../../concept_reference/Object Classes/#node">node</a>s with different temporal resolutions, the constraint is only generated for the lowest resolution, and only the average of the higher resolution flow is constrained. In other words, what gets constrained is the &quot;average power&quot; (e.g. MWh/h) rather than the &quot;instantaneous power&quot; (e.g. MW). If instantaneous power needs to be constrained as well, then <a href="../../concept_reference/Parameters/#connection_capacity">connection_capacity</a> needs to be specified separately for each <a href="../../concept_reference/Object Classes/#node">node</a> served by the <a href="../../concept_reference/Object Classes/#connection">connection</a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The conversion factor <a href="../../concept_reference/Parameters/#connection_conv_cap_to_flow">connection_conv_cap_to_flow</a> has a default value of <code>1</code>, but can be adjusted in case the unit of measurement for the capacity is different to the connection flows unit of measurement.</p></div></div><h4 id="constraint_ratio_out_in_connection_flow"><a class="docs-heading-anchor" href="#constraint_ratio_out_in_connection_flow">Fixed ratio between outgoing and incoming flows of a connection</a><a id="constraint_ratio_out_in_connection_flow-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_ratio_out_in_connection_flow" title="Permalink"></a></h4><p>By defining the parameters <a href="../../concept_reference/Parameters/#fix_ratio_out_in_connection_flow">fix_ratio_out_in_connection_flow</a>, <a href="../../concept_reference/Parameters/#max_ratio_out_in_connection_flow">max_ratio_out_in_connection_flow</a> or <a href="../../concept_reference/Parameters/#min_ratio_out_in_connection_flow">min_ratio_out_in_connection_flow</a>, a ratio can be set between <strong>out</strong>going and <strong>in</strong>coming flows from and to a connection.</p><p>The constraint below is written for <a href="../../concept_reference/Parameters/#fix_ratio_out_in_connection_flow">fix_ratio_out_in_connection_flow</a>, but equivalent formulations exist for the other two cases.</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{n \in ng_{out}} v^{connection\_flow}_{(conn,n,from\_node,s,t)} \\
&amp; = \\
&amp; p^{fix\_ratio\_out\_in\_connection\_flow}_{(conn, ng_{out}, ng_{in},s,t)}
\cdot \sum_{n \in ng_{in}} v^{connection\_flow}_{(conn,n,to\_node,s,t)} \\
&amp; \forall (conn, ng_{out}, ng_{in}) \in indices(p^{fix\_ratio\_out\_in\_connection\_flow}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If any of the above mentioned ratio parameters is specified for a node group, then the ratio is enforced over the <em>sum</em> of flows from or to that group. In this case, there remains a degree of freedom regarding the composition of flows within the group.</p></div></div><p>See also <a href="../../concept_reference/Parameters/#fix_ratio_out_in_connection_flow">fix_ratio_out_in_connection_flow</a>.</p><h3 id="Specific-network-representation"><a class="docs-heading-anchor" href="#Specific-network-representation">Specific network representation</a><a id="Specific-network-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-network-representation" title="Permalink"></a></h3><p>In the following, the different specific network representations are introduced. While the <a href="@ref static-constraints-connection">Static constraints</a> find application in any of the different networks, the following equations are specific to the discussed use cases. Currently, SpineOpt incorporated equations for pressure driven gas networks, nodal lossless DC power flows and PTDF based lossless DC power flow.</p><h4 id="pressure-driven-gas-transfer-math"><a class="docs-heading-anchor" href="#pressure-driven-gas-transfer-math">Pressure driven gas transfer</a><a id="pressure-driven-gas-transfer-math-1"></a><a class="docs-heading-anchor-permalink" href="#pressure-driven-gas-transfer-math" title="Permalink"></a></h4><p>For gas pipelines it can be relevant a pressure driven gas transfer can be modelled, i.e. to account for linepack flexibility. Generally speaking, the main challenges related to pressure driven gas transfers are the non-convexities associated with the Weymouth equation. In SpineOpt, a convexified MILP representation has been implemented, which as been presented in <a href="https://doi.org/10.1109/PTC.2019.8810632">Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling</a>. The approximation approach is based on the Taylor series expansion around fixed pressure points.</p><p>In addition to the already known variables, such as <a href="../variables/#connection_flow">connection_flow</a> and <a href="../variables/#node_state">node_state</a>, the start and end points of a gas pipeline connection are associated with the variable <a href="../variables/#node_pressure">node_pressure</a>. The variable is triggered by the <a href="../../concept_reference/Parameters/#has_pressure">has_pressure</a> parameter. For more details on how to set up a gas pipeline, see also the advanced concept section <a href="../../advanced_concepts/pressure_driven_gas_transfer/#pressure-driven-gas-transfer">on pressure driven gas transfer</a>.</p><h5 id="constraint_max_node_pressure"><a class="docs-heading-anchor" href="#constraint_max_node_pressure">Maximum node pressure</a><a id="constraint_max_node_pressure-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_max_node_pressure" title="Permalink"></a></h5><p>In order to impose an upper limit on the maximum pressure at a node the parameter <a href="../../concept_reference/Parameters/#max_node_pressure">max_node_pressure</a> can be specified which triggers the following constraint:</p><p class="math-container">\[\sum_{n \in ng} v^{node\_pressure}_{(n,s,t)} \leq p^{max\_node\_pressure}_{(ng,s,t)}
\quad \forall (ng) \in indices(p^{max\_node\_pressure}), \, \forall (s,t)\]</p><p>As indicated in the equation, the parameter <a href="../../concept_reference/Parameters/#max_node_pressure">max_node_pressure</a> can also be defined on a node group, in order to impose an upper limit on the aggregated <a href="../variables/#node_pressure">node_pressure</a> within one node group.</p><p>See also <a href="../../concept_reference/Parameters/#max_node_pressure">max_node_pressure</a>.</p><h5 id="constraint_min_node_pressure"><a class="docs-heading-anchor" href="#constraint_min_node_pressure">Minimum node pressure</a><a id="constraint_min_node_pressure-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_min_node_pressure" title="Permalink"></a></h5><p>In order to impose a lower limit on the pressure at a node the parameter <a href="../../concept_reference/Parameters/#min_node_pressure">min_node_pressure</a> can be specified which triggers the following constraint:</p><p class="math-container">\[\sum_{n \in ng} v^{node\_pressure}_{(n,s,t)} \geq p^{min\_node\_pressure}_{(ng,s,t)}
\quad \forall (ng) \in indices(p^{min\_node\_pressure}), \, \forall (s,t)\]</p><p>As indicated in the equation, the parameter <a href="../../concept_reference/Parameters/#min_node_pressure">min_node_pressure</a> can also be defined on a node group, in order to impose a lower limit on the aggregated <a href="../variables/#node_pressure">node_pressure</a> within one node group.</p><p>See also <a href="../../concept_reference/Parameters/#min_node_pressure">min_node_pressure</a>.</p><h5 id="constraint_compression_factor"><a class="docs-heading-anchor" href="#constraint_compression_factor">Constraint on the pressure ratio between two nodes</a><a id="constraint_compression_factor-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_compression_factor" title="Permalink"></a></h5><p>If a compression station is located in between two nodes, the connection is considered to be active and a compression ratio between the two nodes can be imposed. The parameter <a href="../../concept_reference/Parameters/#compression_factor">compression_factor</a> needs to be defined on a <a href="../../concept_reference/Relationship Classes/#connection__node__node">connection__node__node</a> relationship, where the first node corresponds the origin node, before the compression, while the second node corresponds to the destination node, after compression. The existence of this parameter will trigger the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{n \in ng2} v^{node\_pressure}_{(n,s,t)} \leq p^{compression\_factor}_{(conn,ng1,ng2,s,t)} \cdot \sum_{n \in ng1} v^{node\_pressure}_{(n,s,t)} \\
&amp; \forall (conn,ng1,ng2) \in indices(p^{compression\_factor}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#compression_factor">compression_factor</a>.</p><h5 id="constraint_fixed_node_pressure_point"><a class="docs-heading-anchor" href="#constraint_fixed_node_pressure_point">Outer approximation through fixed pressure points</a><a id="constraint_fixed_node_pressure_point-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_fixed_node_pressure_point" title="Permalink"></a></h5><p>The Weymouth equation relates the average flows through a connection to the difference between the adjacent squared node pressures.</p><p class="math-container">\[\begin{aligned}
&amp; \left(
    \left(
        v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)}
        + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}
    \right)
    - \left(
        v^{connection\_flow}_{(conn, n_{dest},from\_node,s,t)}
        + v^{connection\_flow}_{(conn, n_{orig},to\_node,s,t)}
    \right)
\right)
\\
&amp; \cdot \left\|
    \left(
        v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)}
        + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}
    \right)
    - \left(
        v^{connection\_flow}_{(conn, n_{dest},from\_node,s,t)}
        + v^{connection\_flow}_{(conn, n_{orig},to\_node,s,t)}
    \right)
\right\|
\\
&amp; = 4 \cdot K_{(conn)} \cdot \left(
    \left(v^{node\_pressure}_{(n_{orig},s,t)}\right)^2 - \left(v^{node\_pressure}_{(n_{dest},s,t)}\right)^2
\right) \\
\end{aligned}\]</p><p>where <span>$K$</span> corresponds to the natural gas flow constant.</p><p>The above can be rewritten as</p><p class="math-container">\[\begin{aligned}
&amp; \left(
\left(v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}\right)
- \left(v^{connection\_flow}_{(conn, n_{dest},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{orig},to\_node,s,t)}\right)
\right)\\
&amp; = 2 \cdot \sqrt{
    K_{(conn)}
    \cdot \left(
        \left(v^{node\_pressure}_{(n_{orig},s,t)}\right)^2 - \left(v^{node\_pressure}_{(n_{dest},s,t)}\right)^2
    \right)
} \\
&amp; \text{if } \left(
    v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}
\right) &gt; 0
\end{aligned}\]</p><p>and</p><p class="math-container">\[\begin{aligned}
&amp; \left(
    \left(
        v^{connection\_flow}_{(conn, n_{dest},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{orig},to\_node,s,t)}
    \right)
    - \left(
        v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}
    \right)
\right) \\
&amp; = 2 \cdot \sqrt{
    K_{(conn)} \cdot \left(
        \left(v^{node\_pressure}_{(n_{dest},s,t)}\right)^2 - \left(v^{node\_pressure}_{(n_{orig},s,t)}\right)^2
    \right)
} \\
&amp; \text{if } \left(
    v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}
\right) &lt; 0
\end{aligned}\]</p><p>The cone described by the Weymouth equation can be outer approximated by a number of tangent planes, using a set of fixed pressure points, as illustrated in <a href="https://orbit.dtu.dk/en/publications/integration-of-electricity-natural-gas-and-heat-systems-with-mark">Schwele - Integration of Electricity, Natural Gas and Heat Systems With Market-based Coordination</a>. The big M method is used to replace the sign function.</p><p>The linearized version of the Weymouth equation implemented in SpineOpt is given as follows:</p><p class="math-container">\[\begin{aligned}
&amp; 
\left.
\left(v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}\right)
\middle/2 
\right.
\\
&amp; \leq p^{fixed\_pressure\_constant\_1}_{(conn,n_{orig},n_{dest},j,s,t)} \cdot v^{node\_pressure}_{(n_{orig},s,t)} \\
&amp; - p^{fixed\_pressure\_constant\_0}_{(conn,n_{orig},n_{dest},j,s,t)} \cdot v^{node\_pressure}_{(n_{dest},s,t)} \\
&amp; + p^{big\_m} \cdot \left(1 - v^{binary\_gas\_connection\_flow}_{(conn, n_{dest}, to\_node, s, t)}\right) \\
&amp; \forall (conn, n_{orig}, n_{dest}) \in indices(p^{fixed\_pressure\_constant\_1}) \\
&amp; \forall j \in \left\{1, \ldots, \left\| p^{fixed\_pressure\_constant\_1}_{(conn, n_{orig}, n_{dest})} \right\| \right\}:
p^{fixed\_pressure\_constant\_1}_{(conn, n_{orig}, n_{dest}, j)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>The parameters <a href="../../concept_reference/Parameters/#fixed_pressure_constant_1">fixed_pressure_constant_1</a> and <a href="../../concept_reference/Parameters/#fixed_pressure_constant_0">fixed_pressure_constant_0</a> should be defined. For each considered fixed pressure point, they can be calculated as follows:</p><p class="math-container">\[\begin{aligned}
  &amp; p^{fixed\_pressure\_constant\_1}_{(conn,n_{orig},n_{dest},j)} =
  \left. K_{(conn)} \cdot p^{fixed\_pressure}_{(n_{orig},j)} \middle/ \sqrt{
    \left(p^{fixed\_pressure}_{(n_{orig},j)}\right)^2 - \left(p^{fixed\_pressure}_{(n_{dest},j)}\right)^2
  }\right. \\
  &amp; p^{fixed\_pressure\_constant\_0}_{(conn,n_{orig},n_{dest},j)} =
  \left. K_{(conn)} \cdot p^{fixed\_pressure}_{(n_{dest},j)} \middle/ \sqrt{
    \left(p^{fixed\_pressure}_{(n_{orig},j)}\right)^2 - \left(p^{fixed\_pressure}_{(n_{dest},j)}\right)^2
  }\right. \\
\end{aligned}\]</p><p>where <span>$p^{fixed\_pressure}_{(n,j)}$</span> is the fix pressure for node <span>$n$</span> and point <span>$j$</span>.</p><p>The <a href="../../concept_reference/Parameters/#big_m">big_m</a> parameter combined with the variable <a href="../variables/#binary_gas_connection_flow">binary_gas_connection_flow</a> together with the equations <a href="@ref constraint_connection_unitary_gas_flow">on unitary gas flow</a> and on the <a href="@ref constraint_connection_flow_gas_capacity">maximum gas flow</a> ensure that the bound on the average flow through the fixed pressure points becomes active, if the flow is in a positive direction for the observed set of connection, node1 and node2.</p><p>See also <a href="../../concept_reference/Parameters/#fixed_pressure_constant_1">fixed_pressure_constant_1</a>, <a href="../../concept_reference/Parameters/#fixed_pressure_constant_0">fixed_pressure_constant_0</a>, <a href="../../concept_reference/Parameters/#big_m">big_m</a>.</p><h5 id="constraint_connection_unitary_gas_flow"><a class="docs-heading-anchor" href="#constraint_connection_unitary_gas_flow">Enforcing unidirectional flow</a><a id="constraint_connection_unitary_gas_flow-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_unitary_gas_flow" title="Permalink"></a></h5><p>The flow through a connection can only be in one direction at at time. Whether a flow is active in a certain direction is indicated by the <a href="../variables/#binary_gas_connection_flow">binary_gas_connection_flow</a> variable, which takes a value of <code>1</code> if the direction of flow is positive. To ensure that the <a href="../variables/#binary_gas_connection_flow">binary_gas_connection_flow</a> in the opposite direction then takes the value <code>0</code>, the following constraint is enforced:</p><p class="math-container">\[\begin{aligned}
&amp; v^{binary\_gas\_connection\_flow}_{(conn, n_{orig}, to\_node, s, t)} \\
&amp; = 1 - v^{binary\_gas\_connection\_flow}_{(conn, n_{dest}, to\_node, s, t)} \\
&amp; \forall (conn, n_{orig}, n_{dest}) \in indices(p^{fixed\_pressure\_constant\_1}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><h5 id="constraint_connection_flow_gas_capacity"><a class="docs-heading-anchor" href="#constraint_connection_flow_gas_capacity">Gas connection flow capacity</a><a id="constraint_connection_flow_gas_capacity-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_flow_gas_capacity" title="Permalink"></a></h5><p>To enforce that the averge flow of a connection is only in one direction, the flow in the opposite direction is forced to be <code>0</code> by the following equation. For the connection flow in the direction of flow the parameter <a href="../../concept_reference/Parameters/#big_m">big_m</a> should be chosen large enough not to become binding.</p><p class="math-container">\[\begin{aligned}
&amp; 
\left.
\left(v^{connection\_flow}_{(conn, n_{orig},from\_node,s,t)} + v^{connection\_flow}_{(conn, n_{dest},to\_node,s,t)}\right)
\middle/2 
\right.
\\
&amp; &lt;= p^{big\_m} \cdot v^{binary\_gas\_connection\_flow}_{(conn, n_{dest}, to\_node, s, t)} \\
&amp; \forall (conn, n_{orig}, n_{dest}) \in indices(p^{fixed\_pressure\_constant\_1}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="@ref">p^{fixed_pressure_constant_1}</a>, <a href="../../concept_reference/Parameters/#big_m">big_m</a>.</p><h5 id="constraint_storage_line_pack"><a class="docs-heading-anchor" href="#constraint_storage_line_pack">Linepack storage flexibility</a><a id="constraint_storage_line_pack-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_storage_line_pack" title="Permalink"></a></h5><p>In order to account for linepack flexibility, i.e. storage capability of a connection, the linepack storage is linked to the average pressure of the adjacent nodes by the following equation, triggered by the parameter <a href="../../concept_reference/Parameters/#connection_linepack_constant">connection_linepack_constant</a>:</p><p class="math-container">\[\begin{aligned}
&amp; v^{node\_state}_{(n_{stor},s,t)} = \left(
    p^{connection\_linepack\_constant}_{(conn,n_{stor},ng)} \middle/ 2
\right) \cdot \sum_{n \in ng} v^{node\_pressure}_{(n,s,t)} \\
&amp; \forall (conn, n_{stor}, ng) \in indices(p^{connection\_linepack\_constant}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parameter <a href="../../concept_reference/Parameters/#connection_linepack_constant">connection_linepack_constant</a> should be defined on a <a href="../../concept_reference/Relationship Classes/#connection__node__node">connection__node__node</a>relationship, where the first node corresponds to the linepack storage node, whereas the second node corresponds to the node group of both start and end nodes of the pipeline.</p></div></div><p>See also <a href="../../concept_reference/Parameters/#connection_linepack_constant">connection_linepack_constant</a></p><h4 id="nodal-lossless-DC"><a class="docs-heading-anchor" href="#nodal-lossless-DC">Node-based lossless DC power flow</a><a id="nodal-lossless-DC-1"></a><a class="docs-heading-anchor-permalink" href="#nodal-lossless-DC" title="Permalink"></a></h4><p>For the implementation of the nodebased loss DC powerflow model, a new variable <a href="../variables/#node_voltage_angle">node_voltage_angle</a> is introduced. See also <a href="../../concept_reference/Parameters/#has_voltage_angle">has_voltage_angle</a>. For further explanation on setting up a database for nodal lossless DC power flow, see the advanced concept chapter on <a href="../../advanced_concepts/Lossless_DC_power_flow/#Lossless-nodal-DC-power-flows">Lossless nodal DC power flows</a>.</p><h5 id="constraint_max_node_voltage_angle"><a class="docs-heading-anchor" href="#constraint_max_node_voltage_angle">Maximum node voltage angle</a><a id="constraint_max_node_voltage_angle-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_max_node_voltage_angle" title="Permalink"></a></h5><p>In order to impose an upper limit on the maximum voltage angle at a node the parameter <a href="../../concept_reference/Parameters/#max_voltage_angle">max_voltage_angle</a> can be specified which triggers the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{n \in ng} v^{node\_voltage\_angle}_{(n,s,t)} \geq p^{max\_voltage\_angle}_{(ng,s,t)} \\
&amp; \forall ng \in indices(p^{max\_voltage\_angle}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>As indicated in the equation, the parameter <a href="../../concept_reference/Parameters/#max_voltage_angle">max_voltage_angle</a> can also be defined on a node group, in order to impose an upper limit on the aggregated <a href="../variables/#node_voltage_angle">node_voltage_angle</a> within one node group.</p><p>See also <a href="../../concept_reference/Parameters/#max_voltage_angle">max_voltage_angle</a>.</p><h5 id="constraint_min_node_voltage_angle"><a class="docs-heading-anchor" href="#constraint_min_node_voltage_angle">Minimum node voltage angle</a><a id="constraint_min_node_voltage_angle-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_min_node_voltage_angle" title="Permalink"></a></h5><p>In order to impose a lower limit on the voltage angle at a node the parameter <a href="../../concept_reference/Parameters/#min_voltage_angle">min_voltage_angle</a> can be specified which triggers the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{n \in ng} v^{node\_voltage\_angle}_{(n,s,t)} \leq p^{min\_voltage\_angle}_{(ng,s,t)} \\
&amp; \forall ng \in indices(p^{min\_voltage\_angle}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>As indicated in the equation, the parameter <a href="../../concept_reference/Parameters/#min_voltage_angle">min_voltage_angle</a> can also be defined on a node group, in order to impose a lower limit on the aggregated <a href="../variables/#node_voltage_angle">node_voltage_angle</a> within one node group.</p><p>See also <a href="../../concept_reference/Parameters/#min_voltage_angle">min_voltage_angle</a>.</p><h5 id="constraint_node_voltage_angle"><a class="docs-heading-anchor" href="#constraint_node_voltage_angle">Voltage angle to connection flows</a><a id="constraint_node_voltage_angle-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_node_voltage_angle" title="Permalink"></a></h5><p>To link the flow over a connection to the voltage angles of the adjacent nodes, the following constraint is imposed. Note that this constraint is only generated if the parameter <a href="../../concept_reference/Parameters/#connection_reactance">connection_reactance</a> is defined for a <a href="../../concept_reference/Object Classes/#connection">connection</a> object and if a <a href="../../concept_reference/Parameters/#fix_ratio_out_in_connection_flow">fix_ratio_out_in_connection_flow</a> is defined for a <a href="../../concept_reference/Relationship Classes/#connection__node__node">connection__node__node</a> relationship involving that <a href="../../concept_reference/Object Classes/#connection">connection</a>.</p><p class="math-container">\[\begin{aligned}
&amp; \sum_{n \in ng_{from}} v^{connection\_flow}_{(conn,n,from\_node,s,t)}
- \sum_{n \in ng_{to}} v^{connection\_flow}_{(conn,n,from\_node,s,t)}\\
&amp; = \\
&amp; \left(p^{connection\_reactance\_base}_{(conn,s,t)} \middle/ p^{connection\_reactance}_{(conn,s,t)}\right) \\
&amp; \cdot \left(\sum_{n \in ng_{from}} v^{node\_voltage\_angle}_{(n,s,t)} - \sum_{n \in ng_{to}} v^{node\_voltage\_angle}_{(n,s,t)} \right)\\
&amp; \forall (conn, ng_{to}, ng_{from}) \in indices(p^{fix\_ratio\_out\_in\_connection\_flow})\\
&amp; \forall (s,t)
\end{aligned}\]</p><p>See also <a href="../../concept_reference/Parameters/#connection_reactance">connection_reactance</a>, <a href="../../concept_reference/Parameters/#connection_reactance_base">connection_reactance_base</a>, <a href="../../concept_reference/Parameters/#fix_ratio_out_in_connection_flow">fix_ratio_out_in_connection_flow</a>.</p><h3 id="PTDF-lossless-DC"><a class="docs-heading-anchor" href="#PTDF-lossless-DC">PTDF based DC lossless powerflow</a><a id="PTDF-lossless-DC-1"></a><a class="docs-heading-anchor-permalink" href="#PTDF-lossless-DC" title="Permalink"></a></h3><h4 id="constraint_connection_intact_flow_ptdf"><a class="docs-heading-anchor" href="#constraint_connection_intact_flow_ptdf">Connection intact flow PTDF</a><a id="constraint_connection_intact_flow_ptdf-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_intact_flow_ptdf" title="Permalink"></a></h4><p>The power transfer distribution factors are a property of the network reactances. <span>$p^{ptdf}_{(c, n)}$</span> represents the fraction of an injection at <a href="../../concept_reference/Object Classes/#node">node</a> <span>$n$</span> that will flow on <a href="../../concept_reference/Object Classes/#connection">connection</a> <span>$c$</span>. The flow on <a href="../../concept_reference/Object Classes/#connection">connection</a> <span>$c$</span> is then the sum over all nodes of <span>$p^{ptdf}_{(c, n)}$</span> multiplied by the net injection at that node. <a href="../variables/#connection_intact_flow">connection_intact_flow</a> represents the flow on each line of the network with all candidate connections with PTDF-based flow present in the network.</p><p class="math-container">\[\begin{aligned}
&amp; v^{connection\_intact\_flow}_{(c, n_{to}, to\_node, s, t)}
- v^{connection\_intact\_flow}_{(c, n_{to}, from\_node, s, t)} \\
&amp; = \sum_{n_{inj}} p^{ptdf}_{(c, n_{inj}, t)} \cdot v^{node\_injection}_{(n_{inj}, s, t)}
\cdot \left[p^{node\_opf\_type}_{(n_{inj})} \neq node\_opf\_type\_reference \right]
\\
&amp; \forall c \in connection : p^{is\_monitored}_{(c)} \\
&amp; \forall (s,t)
\end{aligned}\]</p><p>where</p><p class="math-container">\[[p] \vcentcolon = \begin{cases}
1 &amp; \text{if } p \text{ is true;}\\
0 &amp; \text{otherwise.}
\end{cases}\]</p><h4 id="constraint_connection_flow_lodf"><a class="docs-heading-anchor" href="#constraint_connection_flow_lodf">N-1 post contingency connection flow limits</a><a id="constraint_connection_flow_lodf-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_flow_lodf" title="Permalink"></a></h4><p>The N-1 security constraint for the post-contingency flow on monitored connection, <span>$c_{mon}$</span>, upon the outage of a contingency connection, <span>$c_{cont}$</span>, is formed using line outage distribution factors (LODF). <span>$p^{lodf}_{(c_{cont}, c_{mon})}$</span> represents the fraction of the pre-contingency flow on connection <span>$c_{cont}$</span> that will flow on <span>$c_{mon}$</span> if the former is disconnected. If <a href="../../concept_reference/Object Classes/#connection">connection</a> <span>$c_{cont}$</span> is disconnected, the post-contingency flow on the monitored connection <a href="../../concept_reference/Object Classes/#connection">connection</a> <span>$c_{mon}$</span> is the pre-contingency <a href="../variables/#connection_flow">connection_flow</a> on <span>$c_{mon}$</span> plus the LODF times the pre-contingency <a href="../variables/#connection_flow">connection_flow</a> on <span>$c_{cont}$</span>. This post-contingency flow should be less than the <a href="../../concept_reference/Parameters/#connection_emergency_capacity">connection_emergency_capacity</a> of <span>$c_{mon}$</span>.</p><p class="math-container">\[\begin{aligned}
&amp; v^{connection\_flow}_{(c_{mon}, n_{mon\_to}, to\_node, s, t)}
- v^{connection\_flow}_{(c_{mon}, n_{mon\_to}, from\_node, s, t)} \\
&amp; + p^{lodf}_{(c_{cont}, c_{mon})} \cdot \left(             
v^{connection\_flow}_{(c_{cont}, n_{cont\_to}, to\_node, s, t)}
- v^{connection\_flow}_{(c_{cont}, n_{cont\_to}, from\_node, s, t)}
\right) \\
&amp; \leq min \left(
    p^{connection\_emergency\_capacity}_{(c_{mon}, n_{cont\_to}, to\_node, s, t)},
    p^{connection\_emergency\_capacity}_{(c_{mon}, n_{cont\_to}, from\_node,s ,t)}
\right) \\
&amp; \forall (c_{mon}, c_{cont}) \in connection \times connection :
p^{is\_monitored}_{(c_{mon})} \land p^{is\_contingency}_{(c_{cont})} \\
&amp; \forall (s,t)
\end{aligned}\]</p><h2 id="Investments"><a class="docs-heading-anchor" href="#Investments">Investments</a><a id="Investments-1"></a><a class="docs-heading-anchor-permalink" href="#Investments" title="Permalink"></a></h2><h3 id="Investments-in-units"><a class="docs-heading-anchor" href="#Investments-in-units">Investments in units</a><a id="Investments-in-units-1"></a><a class="docs-heading-anchor-permalink" href="#Investments-in-units" title="Permalink"></a></h3><h4 id="constraint_unit_lifetime"><a class="docs-heading-anchor" href="#constraint_unit_lifetime">Technical lifetime of a unit</a><a id="constraint_unit_lifetime-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_unit_lifetime" title="Permalink"></a></h4><p>Constrain <a href="../variables/#units_invested_available">units_invested_available</a> by the investment lifetime of a unit. The parameter <a href="../../concept_reference/Parameters/#unit_investment_lifetime_sense">unit_investment_lifetime_sense</a> defaults to minimum investment lifetime (<a href="../../concept_reference/Parameters/#unit_investment_lifetime_sense">unit_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&gt;=</code></a>), but can be changed to allow strict investment lifetime (<a href="../../concept_reference/Parameters/#unit_investment_lifetime_sense">unit_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>==</code></a>) or maximum investment lifetime (<a href="../../concept_reference/Parameters/#unit_investment_lifetime_sense">unit_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&lt;=</code></a>). The unit lifetime is enforced by the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; v^{units\_invested\_available}_{(u,s,t)}
- \sum_{
        t\_past = t-p^{unit\_investment\_tech\_lifetime}
}^{t}
v^{units\_invested}_{(u,s,t\_past)} \\
&amp; \begin{cases}
\ge &amp; \text{if } p^{unit\_investment\_lifetime\_sense} = &quot;&gt;=&quot; \\
= &amp; \text{if } p^{unit\_investment\_lifetime\_sense} = &quot;==&quot; \\
\le &amp; \text{if } p^{unit\_investment\_lifetime\_sense} = &quot;&lt;=&quot; \\
\end{cases} \\
&amp; 0 \\
&amp; \forall (u,s,t)
\end{aligned}\]</p><h3 id="constraint_units_invested_available"><a class="docs-heading-anchor" href="#constraint_units_invested_available">Available Investment Units</a><a id="constraint_units_invested_available-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_units_invested_available" title="Permalink"></a></h3><p>The number of available invested-in units at any point in time is less than the number of investment candidate units.</p><p class="math-container">\[\begin{aligned}
&amp; v^{units\_invested\_available}_{(u,s,t)} &lt; p^{candidate\_units}_{(u)} \\
&amp; \forall u \in unit: p^{candidate\_units}_{(u)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_units_invested_transition"><a class="docs-heading-anchor" href="#constraint_units_invested_transition">Investment transfer</a><a id="constraint_units_invested_transition-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_units_invested_transition" title="Permalink"></a></h4><p><a href="../variables/#units_invested">units_invested</a> represents the point-in-time decision to invest in a unit or not, while <a href="../variables/#units_invested_available">units_invested_available</a> represents the invested-in units that are available at a specific time. This constraint enforces the relationship between <a href="../variables/#units_invested">units_invested</a>, <a href="../variables/#units_invested_available">units_invested_available</a> and <a href="../variables/#units_mothballed">units_mothballed</a> in adjacent timeslices.</p><p class="math-container">\[\begin{aligned}
&amp; v^{units\_invested\_available}_{(u,s,t)} - v^{units\_invested}_{(u,s,t)}
+ v^{units\_monthballed}_{(u,s,t)}
= v^{units\_invested\_available}_{(u,s,t-1)} \\
&amp; \forall u \in unit: p^{candidate\_units}_{(u)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h3 id="Investments-in-connections"><a class="docs-heading-anchor" href="#Investments-in-connections">Investments in connections</a><a id="Investments-in-connections-1"></a><a class="docs-heading-anchor-permalink" href="#Investments-in-connections" title="Permalink"></a></h3><h3 id="constraint_connections_invested_available"><a class="docs-heading-anchor" href="#constraint_connections_invested_available">Available invested-in connections</a><a id="constraint_connections_invested_available-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connections_invested_available" title="Permalink"></a></h3><p>The number of available invested-in connections at any point in time is less than the number of investment candidate connections.</p><p class="math-container">\[\begin{aligned}
&amp; v^{connections\_invested\_available}_{(c,s,t)} &lt; p^{candidate\_connections}_{(c)} \\
&amp; \forall c \in connection: p^{candidate\_connections}_{(c)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h3 id="constraint_connections_invested_transition"><a class="docs-heading-anchor" href="#constraint_connections_invested_transition">Transfer of previous investments</a><a id="constraint_connections_invested_transition-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connections_invested_transition" title="Permalink"></a></h3><p><a href="../variables/#connections_invested">connections_invested</a> represents the point-in-time decision to invest in a connection or not while <a href="../variables/#connections_invested_available">connections_invested_available</a> represents the invested-in connections that are available at a specific time. This constraint enforces the relationship between <a href="../variables/#connections_invested">connections_invested</a>, <a href="../variables/#connections_invested_available">connections_invested_available</a> and <a href="../variables/#connections_decommissioned">connections_decommissioned</a> in adjacent timeslices.</p><p class="math-container">\[\begin{aligned}
&amp; v^{connections\_invested\_available}_{(c,s,t)} - v^{connections\_invested}_{(c,s,t)}
+ v^{connections\_decommissioned}_{(c,s,t)} \\
&amp; = v^{connections\_invested\_available}_{(c,s,t-1)} \\
&amp; \forall c \in connection: p^{candidate\_connections}_{(c)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_connection_flow_intact_flow"><a class="docs-heading-anchor" href="#constraint_connection_flow_intact_flow">Intact network ptdf-based flows on connections</a><a id="constraint_connection_flow_intact_flow-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_flow_intact_flow" title="Permalink"></a></h4><p>Enforces the relationship between <a href="../variables/#connection_intact_flow">connection_intact_flow</a> (flow with all investments assumed in force) and <a href="../variables/#connection_flow">connection_flow</a>. This constraint ensures that the <a href="../variables/#connection_flow">connection_flow</a> is <a href="../variables/#connection_intact_flow">connection_intact_flow</a> plus additional flow contributions from investment connections that are not invested in.</p><p class="math-container">\[\begin{aligned}
&amp; \left(v^{connection\_flow}_{(c, n_{to}, from\_node, s, t)}
- v^{connection\_flow}_{(c, n_{to}, to\_node, s, t)} \right)
- \left(v^{connection\_intact\_flow}_{(c, n_{to}, from\_node, s, t)}
- v^{connection\_intact\_flow}_{(c, n_{to}, to\_node, s, t)} \right) \\
&amp; =\\
&amp; \sum_{c_{cand}} p^{lodf}_{(c_{cand}, c)} \cdot \left[p^{candidate\_connections}_{(c_{cand})} \neq 0 \right] \cdot \Big( \\
&amp; \qquad \left(
    v^{connection\_flow}_{(c_{cand}, n_{to\_cand}, from\_node, s, t)}
    - v^{connection\_flow}_{(c_{cand}, n_{to\_cand}, to\_node, s, t)} 
\right)
\\
&amp; \qquad 
- \left(
    v^{connection\_intact\_flow}_{(c_{cand}, n_{to\_cand}, from\_node, s, t)}
    - v^{connection\_intact\_flow}_{(c_{cand}, n_{to\_cand}, to\_node, s, t)}
\right)
\\
&amp; \Big) \\
&amp; \forall c \in connection : p^{is\_monitored}_{(c)} \land p^{candidate\_connections}_{(c)} = 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_connection_intact_flow_capacity"><a class="docs-heading-anchor" href="#constraint_connection_intact_flow_capacity">Intact connection flow capacity</a><a id="constraint_connection_intact_flow_capacity-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_intact_flow_capacity" title="Permalink"></a></h4><p>Similarly to <a href="@ref constraint_connection_flow_capacity">this</a>, limits <a href="../variables/#connection_intact_flow">connection_intact_flow</a> according to <a href="../../concept_reference/Parameters/#connection_capacity">connection_capacity</a></p><p class="math-container">\[\begin{aligned}
&amp; \sum_{
n \in ng
} v^{connection\_intact\_flow}_{(conn,n,d,s,t)} \\
&amp; \leq \\
&amp; p^{connection\_capacity}_{(conn,ng,d,s,t)} \cdot p^{connection\_availability\_factor}_{(conn,s,t)}
\cdot p^{connection\_conv\_cap\_to\_flow}_{(conn,ng,d,s,t)} \\
&amp; \cdot \left( p^{number\_of\_connections}_{(conn,s,t)} + p^{candidate\_connections}_{(conn,s,t)} \right)
\\
&amp; \forall (conn,ng,d) \in indices(p^{connection\_capacity}) \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_ratio_out_in_connection_intact_flow"><a class="docs-heading-anchor" href="#constraint_ratio_out_in_connection_intact_flow">Fixed ratio between outgoing and incoming intact flows of a connection</a><a id="constraint_ratio_out_in_connection_intact_flow-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_ratio_out_in_connection_intact_flow" title="Permalink"></a></h4><p>For PTDF-based lossless DC power flow, ensures that the output flow to the <span>$to\_node$</span> equals the input flow from the <span>$from\_node$</span>.</p><p class="math-container">\[\begin{aligned}              
&amp; v^{connection\_intact\_flow}_{(c, n_{out}, d_{to}, s, t)}
=
v^{connection\_intact\_flow}_{(c, n_{in}, d_{from}, s, t)} \\
&amp; \forall c \in connection : p^{is\_monitored}_{(c)} \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_candidate_connection_flow_lb"><a class="docs-heading-anchor" href="#constraint_candidate_connection_flow_lb">Lower bound on candidate connection flow</a><a id="constraint_candidate_connection_flow_lb-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_candidate_connection_flow_lb" title="Permalink"></a></h4><p>For candidate connections with PTDF-based poweflow, together with <a href="@ref constraint_candidate_connection_flow_ub">this</a>, this constraint ensures that <a href="../variables/#connection_flow">connection_flow</a> is zero if the candidate connection is not invested-in and equals <a href="../variables/#connection_intact_flow">connection_intact_flow</a> otherwise.</p><p class="math-container">\[\begin{aligned}
&amp; v^{connection\_flow}_{(c, n, d, s, t)} \\
&amp; \geq \\
&amp; v^{connection\_intact\_flow}_{(c, n, d, s, t)}
- p^{connection\_capacity}_{(c, n, d, s, t)} \cdot \left(
    p^{candidate\_connections}_{(c, s, t)} - v^{connections\_invested\_available}_{(c, s, t)} \right) \\
&amp; \forall c \in connection : p^{candidate\_connections}_{(c)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_candidate_connection_flow_ub"><a class="docs-heading-anchor" href="#constraint_candidate_connection_flow_ub">Upper bound on candidate connection flow</a><a id="constraint_candidate_connection_flow_ub-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_candidate_connection_flow_ub" title="Permalink"></a></h4><p>For candidate connections with PTDF-based poweflow, together with <a href="@ref constraint_candidate_connection_flow_lb">this</a>, this constraint ensures that <a href="../variables/#connection_flow">connection_flow</a> is zero if the candidate connection is not invested-in and equals <a href="../variables/#connection_intact_flow">connection_intact_flow</a> otherwise.</p><p class="math-container">\[\begin{aligned}
&amp; v^{connection\_flow}_{(c, n, d, s, t)} 
\leq
v^{connection\_intact\_flow}_{(c, n, d, s, t)} \\
&amp; \forall c \in connection : p^{candidate\_connections}_{(c)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_connection_lifetime"><a class="docs-heading-anchor" href="#constraint_connection_lifetime">Technical lifetime of a connection</a><a id="constraint_connection_lifetime-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_connection_lifetime" title="Permalink"></a></h4><p>Constrain <a href="../variables/#connections_invested_available">connections_invested_available</a> by the investment lifetime of a connection. The parameter <a href="../../concept_reference/Parameters/#connection_investment_lifetime_sense">connection_investment_lifetime_sense</a> defaults to minimum investment  lifetime (<a href="../../concept_reference/Parameters/#connection_investment_lifetime_sense">connection_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&gt;=</code></a>), but can be changed to strict lifetime (<a href="../../concept_reference/Parameters/#connection_investment_lifetime_sense">connection_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>==</code></a>) or maximum investment lifetime (<a href="../../concept_reference/Parameters/#connection_investment_lifetime_sense">connection_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&lt;=</code></a>). The connection lifetime is enforced by the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; v^{connections\_invested\_available}_{(conn,s,t)}
- \sum_{
        t\_past = t-p^{connection\_investment\_tech\_lifetime}
}^{t}
v^{connections\_invested}_{(conn,s,t\_past)} \\
&amp; \begin{cases}
\ge &amp; \text{if } p^{connection\_investment\_lifetime\_sense} = &quot;&gt;=&quot; \\
= &amp; \text{if } p^{connection\_investment\_lifetime\_sense} = &quot;==&quot; \\
\le &amp; \text{if } p^{connection\_investment\_lifetime\_sense} = &quot;&lt;=&quot; \\
\end{cases} \\
&amp; 0 \\
&amp; \forall (conn,s,t)
\end{aligned}\]</p><h3 id="Investments-in-storages"><a class="docs-heading-anchor" href="#Investments-in-storages">Investments in storages</a><a id="Investments-in-storages-1"></a><a class="docs-heading-anchor-permalink" href="#Investments-in-storages" title="Permalink"></a></h3><p>Note: can we actually invest in nodes that are not storages? (e.g. new location)</p><h4 id="constraint_storages_invested_available"><a class="docs-heading-anchor" href="#constraint_storages_invested_available">Available invested storages</a><a id="constraint_storages_invested_available-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_storages_invested_available" title="Permalink"></a></h4><p>The number of available invested-in storages at node <span>$n$</span> at any point in time is less than the number of investment candidate storages at that node.</p><p class="math-container">\[\begin{aligned}
&amp; v^{storages\_invested\_available}_{(n,s,t)}
\leq p^{candidate\_storages}_{(n,s,t)} \\
&amp; \forall n \in node: p^{candidate\_storages}_{(n)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_storages_invested_transition"><a class="docs-heading-anchor" href="#constraint_storages_invested_transition">Storage capacity transfer </a><a id="constraint_storages_invested_transition-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_storages_invested_transition" title="Permalink"></a></h4><p><a href="../variables/#storages_invested">storages_invested</a> represents the point-in-time decision to invest in storage at a node <span>$n$</span> or not, while <a href="../variables/#storages_invested_available">storages_invested_available</a> represents the invested-in storages that are available at a node at a specific time. This constraint enforces the relationship between <a href="../variables/#storages_invested">storages_invested</a>, <a href="../variables/#storages_invested_available">storages_invested_available</a> and <a href="../variables/#storages_decommissioned">storages_decommissioned</a> in adjacent timeslices.</p><p class="math-container">\[\begin{aligned}
&amp; v^{storages\_invested\_available}_{(n,s,t)} - v^{storages\_invested}_{(n,s,t)}
+ v^{storages\_decommissioned}_{(n,s,t)}
= v^{storages\_invested\_available}_{(n,s,t-1)} \\
&amp; \forall n \in node: p^{candidate\_storages}_{(n)} \neq 0 \\
&amp; \forall (s,t)
\end{aligned}\]</p><h4 id="constraint_storage_lifetime"><a class="docs-heading-anchor" href="#constraint_storage_lifetime">Technical lifetime of a storage</a><a id="constraint_storage_lifetime-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_storage_lifetime" title="Permalink"></a></h4><p>Constrain <a href="../variables/#storages_invested_available">storages_invested_available</a> by the investment lifetime of a storage. The parameter <a href="../../concept_reference/Parameters/#storage_investment_lifetime_sense">storage_investment_lifetime_sense</a> defaults to minimum investment lifetime (<a href="../../concept_reference/Parameters/#storage_investment_lifetime_sense">storage_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&gt;=</code></a>), but can be changed to allow strict investment lifetime (<a href="../../concept_reference/Parameters/#storage_investment_lifetime_sense">storage_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>==</code></a>) or maximum investment lifetime (<a href="../../concept_reference/Parameters/#storage_investment_lifetime_sense">storage_investment_lifetime_sense</a> <a href="../../concept_reference/Parameter Value Lists/#constraint_sense_list"><code>&lt;=</code></a>). The storage lifetime is enforced by the following constraint:</p><p class="math-container">\[\begin{aligned}
&amp; v^{storages\_invested\_available}_{(n,s,t)}
- \sum_{
        t\_past = t-p^{storage\_investment\_tech\_lifetime}
}^{t}
v^{storages\_invested}_{(n,s,t\_past)} \\
&amp; \begin{cases}
\ge &amp; \text{if } p^{storage\_investment\_lifetime\_sense} = &quot;&gt;=&quot; \\
= &amp; \text{if } p^{storage\_investment\_lifetime\_sense} = &quot;==&quot; \\
\le &amp; \text{if } p^{storage\_investment\_lifetime\_sense} = &quot;&lt;=&quot; \\
\end{cases} \\
&amp; 0 \\
&amp; \forall (n,s,t)
\end{aligned}\]</p><h3 id="Capacity-transfer"><a class="docs-heading-anchor" href="#Capacity-transfer">Capacity transfer</a><a id="Capacity-transfer-1"></a><a class="docs-heading-anchor-permalink" href="#Capacity-transfer" title="Permalink"></a></h3><p>(Comment 2021-04-29: Currently under development)</p><h3 id="Early-retirement-of-capacity"><a class="docs-heading-anchor" href="#Early-retirement-of-capacity">Early retirement of capacity</a><a id="Early-retirement-of-capacity-1"></a><a class="docs-heading-anchor-permalink" href="#Early-retirement-of-capacity" title="Permalink"></a></h3><p>(Comment 2021-04-29: Currently under development)</p><h2 id="User-constraints"><a class="docs-heading-anchor" href="#User-constraints">User constraints</a><a id="User-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#User-constraints" title="Permalink"></a></h2><h3 id="constraint_user_constraint"><a class="docs-heading-anchor" href="#constraint_user_constraint">User constraint</a><a id="constraint_user_constraint-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_user_constraint" title="Permalink"></a></h3><p>This is a generic data-driven custom constraint which allows for defining constraints involving multiple <a href="../../concept_reference/Object Classes/#unit">unit</a>s, <a href="../../concept_reference/Object Classes/#node">node</a>s, or <a href="../../concept_reference/Object Classes/#connection">connection</a>s. The <a href="../../concept_reference/Parameters/#constraint_sense">constraint_sense</a> parameter changes the sense of the <a href="../../concept_reference/Object Classes/#user_constraint">user_constraint</a>, while the <a href="../../concept_reference/Parameters/#right_hand_side">right_hand_side</a> parameter allows for defining the constant term of the constraint.</p><p>Coefficients for the different <a href="../variables/#Variables">variables</a> appearing in the <a href="../../concept_reference/Object Classes/#user_constraint">user_constraint</a> are defined using relationships, like e.g. <a href="../../concept_reference/Relationship Classes/#unit__from_node__user_constraint">unit__from_node__user_constraint</a> and <a href="../../concept_reference/Relationship Classes/#connection__to_node__user_constraint">connection__to_node__user_constraint</a> for <a href="../variables/#unit_flow">unit_flow</a> and <a href="../variables/#connection_flow">connection_flow</a> variables, or <a href="../../concept_reference/Relationship Classes/#unit__user_constraint">unit__user_constraint</a> and <a href="../../concept_reference/Relationship Classes/#node__user_constraint">node__user_constraint</a> for <a href="../variables/#units_on">units_on</a>, <a href="../variables/#units_started_up">units_started_up</a>, and <a href="../variables/#node_state">node_state</a> variables.</p><p>For more information, see the dedicated article on <a href="../../advanced_concepts/user_constraints/#User-Constraints">User Constraints</a></p><p class="math-container">\[\begin{aligned}
&amp; \sum_{u, n} \left\{
  \begin{aligned}     
       &amp; \sum_{op=1}^{\left\| p^{operating\_points}_{(u)} \right\|} p^{unit\_flow\_coefficient}_{(u,n,op,uc,s,t)}
       \cdot v^{unit\_flow\_op}_{(u,n,d,op,s,t)} &amp;\text{if } \left\| p^{operating\_points}_{(u)} \right\| &gt; 1 &amp; \\
       &amp; p^{unit\_flow\_coefficient}_{(u,n,uc,s,t)} \cdot v^{unit\_flow}_{(u,n,d,s,t)} &amp;\text{otherwise} &amp; \\       
  \end{aligned}
  \right.
\\
&amp;+\sum_{u} p^{units\_started\_up\_coefficient}_{(u,uc,s,t)} \cdot v^{units\_started\_up}_{(u,s,t)} \\
&amp;+\sum_{u} p^{units\_on\_coefficient}_{(u,uc,s,t)} \cdot v^{units\_on}_{(u,s,t)} \\
&amp;+\sum_{c} p^{connection\_flow\_coefficient}_{(c,n,uc,s,t)} \cdot v^{connection\_flow}_{(c,n,d,s,t)} \\
&amp;+\sum_{n} p^{node\_state\_coefficient}_{(n,uc,s,t)} \cdot v^{node\_state}_{(n,s,t)} \\
&amp;+\sum_{n} p^{demand\_coefficient}_{(n,uc,s,t)} \cdot p^{demand}_{(n,s,t)} \\
&amp; \begin{cases}  
       = &amp;\text{if } p^{constraint\_sense}_{(uc)} \text{= &quot;==&quot;}\\
       \geq &amp;\text{if } p^{constraint\_sense}_{(uc)} \text{= &quot;&gt;=&quot;}\\
       \leq &amp;\text{if } p^{constraint\_sense}_{(uc)} \text{= &quot;==&quot;}\\
  \end{cases}\\
&amp;+p^{right\_hand\_side}_{(uc,t,s)}\\
&amp;\forall uc \in user\_constraint \\
&amp;\forall (s,t)
\end{aligned}\]</p><h2 id="benders_decomposition"><a class="docs-heading-anchor" href="#benders_decomposition">Benders decomposition</a><a id="benders_decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#benders_decomposition" title="Permalink"></a></h2><p>This section describes the high-level formulation of the benders-decomposed problem.</p><p>Taking the simple example of minimising capacity and operating cost for a fleet of units with a linear cost coefficient <span>$p^{operational\_cost}$</span>:</p><p class="math-container">\[\begin{aligned}
min&amp;
\\
&amp; \sum_{u,s,t} \left( p^{unit\_investment\_cost}_{(u,s,t)} \cdot v^{units\_invested}_{(u,s,t)}
+ \sum_{n,d} p^{operational\_cost}_{(u,n,d,s,t)} \cdot v^{unit\_flow}_{(u, n, d, s, t)} \right) \\
s.t. &amp;
\\
&amp; v^{unit\_flow}_{(u,n,d,s,t)} \le p^{unit\_capacity}_{(u, n, d, s, t)} \cdot \left(
    v^{units\_available}_{(u,s,t)} + v^{units\_invested\_available}_{(u, s, t)}
\right) \quad \forall u \in unit, n \in node, s, t
\\
&amp; \sum_{u,d} v^{unit\_flow}_{(u,n,d,s,t)} = p^{demand}_{(n, s, t)} \quad \forall n \in node, s,t
\end{aligned}\]</p><p>So this is a single problem that can&#39;t be decoupled over <span>$t$</span> because the investment variables <a href="../variables/#units_invested_available">units_invested_available</a> couple the timesteps together. If <a href="../variables/#units_invested_available">units_invested_available</a> were a constant in the problem, then all <span>$t$</span>&#39;s could be solved individually. This is the basic idea in Benders decomposition. We decompose the problem into a master problem and sub problems with the master problem optimising the coupling investment variables which are treated as constants in the sub problems.</p><p>The master problem is built by replacing the operational costs (which will be minimised in the sub problem) by a new decision variable, <span>$v^{sp\_objective}$</span>:</p><p class="math-container">\[\begin{aligned}
min &amp; \\
&amp; \sum_{u,s,t} p^{unit\_investment\_cost}_{(u,s,t)} \cdot v^{units\_invested}_{(u,s,t)} + v^{sp\_objective} \\
s.t. &amp; \\
&amp; v^{sp\_objective} \geq 0
\end{aligned}
\]</p><p>The solution to this problem yields values for the investment variables which are fixed as <span>$p^{units\_invested\_available}$</span> in the sub problem and will be zero in the first iteration.</p><p>The sub problem for benders iteration <span>$b$</span> then becomes :</p><p class="math-container">\[\begin{aligned}
min&amp;
\\
&amp; sp\_obj_b = \sum_{u,n,d,s,t} p^{operational\_cost}_{(u,n,d,s,t)} \cdot v^{unit\_flow}_{(u, n, d, s, t)}\\
s.t.&amp;
\\
&amp; v^{unit\_flow}_{(u,n,d,s,t)} \le p^{unit\_capacity}_{(u, n, d, s, t)} \cdot \left(
    v^{units\_available}_{(u,s,t)} + p^{units\_invested\_available}_{(b, u, s, t)}
\right) \\ 
&amp; \qquad \forall u \in unit, n \in node, s,t \qquad [\mu_{(b,u,s,t)}]
\\
&amp; \sum_{u,d} v^{unit\_flow}_{(u,n,d,s,t)} = p^{demand}_{(n, s, t)} \quad \forall n \in node, s,t
\end{aligned}\]</p><p>This sub problem can be solved individually for each <span>$t$</span>. This is pretty trivial in this small example but if we consider a single t to be a single rolling horizon instead, decoupling the investment variables means that each rolling horizon can be solved individually rather than having to solve the entire model horizon as a single problem.</p><p><span>$\mu_{(b,u,s,t)}$</span> is the marginal value of the capacity constraint for benders iteration <span>$b$</span> and can be interpreted as the decrease in the objective function for an additional MW of flow from unit <span>$u$</span> (in scenario <span>$s$</span> at time <span>$t$</span>). Thus, an upper bound on the sub problem objective function is obtained as follows:</p><p class="math-container">\[sp\_obj_{b} + \sum_{u,n,d,s,t} \mu_{(b,u,s,t)} \cdot p^{unit\_capacity}_{(u,n,d,s,t)} 
\cdot \left(v^{units\_invested\_available}_{(u,s,t)} - p^{units\_invested\_available}_{(b,u,s,t)}\right)\]</p><p>The above is added to the master problem for the next iteration as a new constraint, called a Benders cut, thus becoming:</p><p class="math-container">\[\begin{aligned}
min &amp; \\
&amp; \sum_{u,s,t} p^{unit\_investment\_cost}_{(u,s,t)} \cdot v^{units\_invested}_{(u,s,t)}
+ v^{sp\_objective} \\

s.t. &amp; \\

&amp; v^{sp\_objective} \geq sp\_obj_{b} \\
&amp; \quad + \sum_{u,n,d,s,t} \mu_{(b,u,s,t)} \cdot p^{unit\_capacity}_{(u,n,d,s,t)}
\cdot \left(v^{units\_invested\_available}_{(u,s,t)} - p^{units\_invested\_available}_{(b,u,s,t)}\right) \quad \forall b \\
\end{aligned}\]</p><p>Note the benders cuts are added as inequalities because they represent an upper bound on the value we are going to get for the sub problem objective function by adjusting the master problem variables in that benders iteration. If we consider the example of renewable generation - because it&#39;s marginal cost is zero, on the first benders iteration, it could look like there would be a lot of value in increasing the capacity because of the marginal values from the sub problems. However, when the capacity variables are increased accordingly and curtailment occurs in the sub-problems, the marginal values will be zero when curtailment occurs and so, other resources may become optimal in subsequent iterations.</p><p>This is a simple example but it illustrates the general strategy. The algorithm pseudo code looks something like this:</p><pre><code class="nohighlight hljs">  initialise master problem
  initialise sub problem
  solve first master problem
  create master problem variable time series
  solve rolling spine opt model
  save zipped marginal values
  while master problem not converged
      update master problem
      solve master problem
      update master problem variable timeseries for benders iteration b
      rewind sub problem
      update sub problem
      solve rolling spine opt model
      save zipped marginal values
      test for convergence
  end</code></pre><h3 id="constraint_mp_any_invested_cuts"><a class="docs-heading-anchor" href="#constraint_mp_any_invested_cuts">Benders cuts</a><a id="constraint_mp_any_invested_cuts-1"></a><a class="docs-heading-anchor-permalink" href="#constraint_mp_any_invested_cuts" title="Permalink"></a></h3><p>The benders cuts for the problem including all investments in candidate connections, storages and units is given below.</p><p class="math-container">\[\begin{aligned}
&amp; v^{sp\_objective} \\
&amp; \geq \\
&amp; p^{sp\_obj}_{(b)} + \\
&amp; \sum_{u,s,t} p^{units\_invested\_available\_mv}_{(b,u,s,t)}
\cdot \left( v^{units\_invested\_available}_{(u,s,t)} - p^{units\_invested\_available}_{(u,s,t)} \right) \\
&amp; + \sum_{c,s,t} p^{connections\_invested\_available\_mv}_{(b,c,s,t)}
\cdot \left( v^{connections\_invested\_available}_{(c,s,t)} - p^{connections\_invested\_available}_{(c,s,t)} \right) \\
&amp; + \sum_{n,s,t} p^{storages\_invested\_available\_mv}_{(b,n,s,t)}
\cdot \left( v^{storages\_invested\_available}_{(n,s,t)} - p^{storages\_invested\_available}_{(n,s,t)} \right) \\
\end{aligned}\]</p><p>where</p><ul><li><span>$p^{sp\_obj}_{(b)}$</span> is the sub problem objective function value in benders iteration <span>$b$</span>,</li><li><span>$p^{units\_invested\_available\_mv}$</span> is the reduced cost of the <a href="../variables/#units_invested_available">units_invested_available</a> fixed sub-problem variable, representing the reduction in operating costs possible from an investment in a <a href="../../concept_reference/Object Classes/#unit">unit</a> of this type,  </li><li><span>$p^{connections\_invested\_available\_mv}$</span> is the reduced cost of the <a href="../variables/#connections_invested_available">connections_invested_available</a> fixed sub-problem variable, representing the reduction in operating costs possible from an investment in a <a href="../../concept_reference/Object Classes/#connection">connection</a> of this type,  </li><li><span>$p^{storages\_invested\_available\_mv}$</span> is the reduced cost of the <a href="../variables/#storages_invested_available">storages_invested_available</a> fixed sub-problem variable, representing the reduction in operating costs possible from an investment in a storage <a href="../../concept_reference/Object Classes/#node">node</a> of this type,  </li><li><span>$p^{units\_invested\_available}$</span> is the value of the fixed sub problem variable <a href="../variables/#units_invested_available">units_invested_available</a> in benders iteration <span>$b$</span>,  </li><li><span>$p^{connections\_invested\_available}$</span> is the value of the fixed sub problem variable <a href="../variables/#connections_invested_available">connections_invested_available</a> in benders iteration <span>$b$</span> and  </li><li><span>$p^{storages\_invested\_available}$</span> is the value of the fixed sub problem variable <a href="../variables/#storages_invested_available">storages_invested_available</a> in benders iteration <span>$b$</span></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../objective_function/">« Objective</a><a class="docs-footer-nextpage" href="../../implementation_details/documentation/">Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Friday 30 August 2024 12:31">Friday 30 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
